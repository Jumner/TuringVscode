"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.operatorHoverProvider = exports.moduleHoverProvider = exports.keywordHoverProvider = exports.functionHoverProvider = exports.constantHoverProvider = void 0;
const vscode = require("vscode");
const hoverCompletions_1 = require("./hoverCompletions");
// All the hover providers
exports.constantHoverProvider = vscode.languages.registerHoverProvider('t', {
    provideHover(doc, pos) {
        const range = doc.getWordRangeAtPosition(pos, hoverCompletions_1.constRegex); // Get words based off constants
        const word = doc.getText(range); // Get that word
        if (range) { // If there was a match
            switch (word) { // Switch to find which one
                case 'maxcol': return hoverCompletions_1.hover('The maxcol function is used to determine the number of columns on the screen', word, '(Constant)');
                case 'maxcolour': return hoverCompletions_1.hover('The maxcolour function is used to determine the maximum colour number for the current mode of the screen', word, '(Constant)');
                case 'minint': return hoverCompletions_1.hover('The minimum integer in Turing', word, '(Constant)');
                case 'maxint': return hoverCompletions_1.hover('The maximum integer in Turing', word, '(Constant)');
                case 'minnat': return hoverCompletions_1.hover('The minimum natural number in Turing', word, '(Constant)');
                case 'maxnat': return hoverCompletions_1.hover('The maximum natural number in Turing', word, '(Constant)');
                case 'maxrow': return hoverCompletions_1.hover('The maxrow function is used to determine the number of rows on the screen', word, '(Constant)');
                case 'maxx': return hoverCompletions_1.hover('The maxx function is used to determine the maximum value of x for the current graphics mode', word, '(Constant)');
                case 'maxy': return hoverCompletions_1.hover('The maxy function is used to determine the maximum value of y for the current graphics mode', word, '(Constant)');
                case 'playdone': return hoverCompletions_1.hover('The playdone function is used to determine when notes played by the play procedure have finished sounding', word, '(Constant)');
                case 'whatcol': return hoverCompletions_1.hover('The whatcol function is used to determine the cursor position\'s column', word, '(Constant)');
                case 'whatcolourback': return hoverCompletions_1.hover('The whatcolourback function is used to determine the current text background colour', word, '(Constant)');
                case 'whatcolour': return hoverCompletions_1.hover('he whatcolour function is used to determine the current text (foreground) colour, ie., the color used for characters that are output using put', word, '(Constant)');
                case 'whatrow': return hoverCompletions_1.hover('The whatrow function is used to determine the cursor position\'s row', word, '(Constant)');
                case 'simutime': return hoverCompletions_1.hover('The simutime function returns the number of simulated time units that have passed since program execution began', word, '(Constant)');
                default: return hoverCompletions_1.hover('The keycode returned from getch, getchar, and Input.KeyDown', word, '(Keycode)');
            }
        }
    }
});
exports.functionHoverProvider = vscode.languages.registerHoverProvider('t', {
    provideHover(doc, pos) {
        const range = doc.getWordRangeAtPosition(pos, hoverCompletions_1.functionRegex); // Get words based on functions
        const word = doc.getText(range); // Get that word
        if (range) { // If there was a match
            switch (word) { // Find match
                case 'abs': return hoverCompletions_1.hover('The abs function is used to find the absolute value of a number', 'abs (expn : real) : real', '(Function)', ['expn'], ['Input positive or negative number'], 'Output positive number, absolute of `expn`');
                case 'arccosd': return hoverCompletions_1.hover('The arccosd function is used to find the arc cosine of an angle given in degrees', 'arccosd (r : real) : real', '(Function)', ['r'], ['Input cosine ratio'], 'Output angle (degrees)');
                case 'arccos': return hoverCompletions_1.hover('The arccos function is used to find the arc cosine of a value. The result is given in radians', 'arccos (r : real) : real', '(Function)', ['r'], ['Input cosine ratio'], 'Output angle (radians)');
                case 'arcsind': return hoverCompletions_1.hover('The arcsind function is used to find the arc sine of an angle given in degrees', 'arcsind (r : real) : real', '(Function)', ['r'], ['Input sine ratio'], 'Output angle (degrees)');
                case 'arcsin': return hoverCompletions_1.hover('The arcsin function is used to find the arc sine of a value. The result is given in radians', 'arcsin (r : real) : real', '(Function)', ['r'], ['Input sine ratio'], 'Output angle (radians)');
                case 'arctand': return hoverCompletions_1.hover('The arctand function is used to find the arc tangent of an angle given in degrees', 'arctand (r : real) : real', '(Function)', ['r'], ['Input tangent ratio'], 'Output angle (degrees)');
                case 'arctan': return hoverCompletions_1.hover('The arctan function is used to find the arc tangent of a value. The result is given in radians', 'arctan (r : real) : real', '(Function)', ['r'], ['Input tangent ratio'], 'Output angle (radians)');
                case 'buttonchoose': return hoverCompletions_1.hover('The buttonchoose procedure is used to change the mode of the mouse. In Turing, the mouse can either be in "single-button mode" or in "multi-button mode"', 'buttonchoose (choice : string)', '(Procedure)', ['choice'], ['Mode to put mouse into']);
                case 'buttonmoved': return hoverCompletions_1.hover('The buttonmoved function indicates whether there is a mouse event of the appropriate type on the mouse queue. Events are either "up", "down", "updown" or "downup" events', 'buttonmoved (motion : string) : boolean', '(Function)', ['motion'], ['Event to listen for'], 'If event has occurred');
                case 'buttonwait': return hoverCompletions_1.hover('The buttonwait procedure gets information about a mouse event and removes it from the queue', 'buttonwait (motion : string, var x, y, buttonnumber, buttonupdown : int)', '(Procedure)', ['motion', 'x', 'y', 'buttonnumber', 'buttonupdown'], ['Event to wait for', 'Variable is set to X position', 'Variable is set to Y position', 'Variable set to button id related to event', 'Variable set to event']);
                case 'ceil': return hoverCompletions_1.hover('Returns the smallest integer greater than or equal to r', 'ceil (r : real) : int', '(Function)', ['r'], ['Input real number'], 'Output int that got rounded up');
                case 'chr': return hoverCompletions_1.hover('The chr function is used to convert an integer to a character. The character is the i-th character of the ASCII sequence of characters', 'chr (i : int) : char', '(Function)', ['i'], ['Ascii character id'], 'Output character of Ascii id `i`');
                case 'clock': return hoverCompletions_1.hover('The clock statement is used to determine the amount of time since a program (process) started running', 'clock (var c : int)', '(Procedure)', ['c'], ['Variable set to milliseconds since program started']);
                case 'cls': return hoverCompletions_1.hover('The cls (clear screen) procedure is used to blank the output window. The cursor is set to the top left (to row 1, column 1). This is exactly the same as the Draw.Cls method', 'cls', '(Procedure)');
                case 'colourback': return hoverCompletions_1.hover('The colorback procedure is used to change the color upon which text appears. The alternate spelling is cornerback', 'colourback (Colour : int)', '(Procedure)', ['Colour'], ['Colour id to set background to']);
                case 'colour': return hoverCompletions_1.hover('The color procedure is used to change the currently active color. This is the color of characters that are to be put on the screen. The alternate spelling is colour', 'colour (Colour : int)', '(Procedure)', ['Colour'], ['Colour id to set background to']);
                case 'cosd': return hoverCompletions_1.hover('The cosd function is used to find the cosine of an angle given in degrees', 'cosd (r : real) : real', '(Function)', ['r'], ['Input angle (degrees)'], 'Output cosine ratio');
                case 'cos': return hoverCompletions_1.hover('The cos function is used to find the cosine of an angle given in radians', 'cos (r : real) : real', '(Function)', ['r'], ['Input angle (radians)'], 'Output cosine ratio');
                case 'date': return hoverCompletions_1.hover('The date statement is used to determine the current date. Variable d is assigned a string in the format "dd mmm yy", where mmm is the first 3 characters of the month', 'date (var d : string)', '(Procedure)', ['d'], ['Input string set to today\' date']);
                case 'delay': return hoverCompletions_1.hover('The delay statement is used to cause the program to pause for a given time. The time duration is in milliseconds', 'delay (duration : int)', '(Procedure)', ['duration'], ['Time to delay program for (milliseconds)']);
                case 'drawarc': return hoverCompletions_1.hover('The drawarc procedure is used to draw an arc whose center is at (x, y). This is just like drawoval, except that you must also give two angles, initialAngle and finalAngle, which determine where to start and stop drawing. This is exactly the same as the Draw.Arc method', 'arc (x, y, xRadius, yRadius : int, initialAngle, finalAngle, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'initialAngle', 'finalAngle', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Start angle of the arc. 0 degrees is East, 90 is North', 'End angle of the arc. 0 degrees is East, 90 is North', 'Arc colour']);
                case 'drawbox': return hoverCompletions_1.hover('The drawbox procedure is used to draw a box on the screen with bottom left and top right corners of (x1, y1) to (x2, y2) using the specified Color. This is exactly the same as the Draw.Box method', 'drawbox (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Box colour']);
                case 'drawdot': return hoverCompletions_1.hover('The drawdot procedure is used to color the dot (pixel) at location (x, y) using the specified Color. This is exactly the same as the Draw.Dot method', 'drawdot (x, y, Colour : int)', '(Procedure)', ['x', 'y', 'Colour'], ['X position of dot', 'Y position of dot', 'Colour of dot']);
                case 'drawfillarc': return hoverCompletions_1.hover('The drawfillarc procedure is used to draw a filled arc whose center is at (x, y). It then fills in the pie-shaped wedge using the specified Color. This is exactly the same as the Draw.FillArc method', 'drawfillarc (x, y, xRadius, yRadius : int, initialAngle, finalAngle, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'initialAngle', 'finalAngle', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Start angle of the arc. 0 degrees is East, 90 is North', 'End angle of the arc. 0 degrees is East, 90 is North', 'Arc fill colour']);
                case 'drawfillbox': return hoverCompletions_1.hover('The drawfillbox procedure is used to draw a filled box on the screen with bottom left and top right corners of (x1, y1) to (x2, y2) filled using the specified Color. This is exactly the same as the Draw.FillBox method', 'drawfillbox (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Box fill colour']);
                case 'drawfill': return hoverCompletions_1.hover('The drawfill procedure is used to color in a figure that is on the screen. Starting at (x, y), the figure is filled with fillColor to a surrounding border whose color is borderColor. This is exactly the same as the Draw.Fill method', 'drawfill (x, y : int, fillColor, borderColor : int)', '(Procedure)', ['x', 'y', 'fillColour', 'borderColour'], ['X position of fill', 'Y position of fill', 'Colour to fill in', 'Colour of border']);
                case 'drawfillmapleleaf': return hoverCompletions_1.hover('The drawfillmapleleaf procedure is used to draw a filled maple leaf on the screen bounded by a rectangle with bottom left and top right corners of (x1, y1) to (x2, y2) and filled using the specified Color. This is exactly the same as the Draw.FillMapleLeaf method', 'drawfillmapleleaf (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Maple leaf fill colour']);
                case 'drawfilloval': return hoverCompletions_1.hover('The drawfilloval procedure is used to draw a filled oval whose center is at (x, y). The horizontal and vertical distances from the center to the oval are given by xRadius and yRadius. This is exactly the same as the Draw.FillOval method', 'drawfilloval (x, y, xRadius, yRadius, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Oval fill colour']);
                case 'drawfillpolygon': return hoverCompletions_1.hover('The drawfillpolygon procedure is used to draw a filled polygon with n points. The polygon is described by the points (x(1), y(1)) to (x(2), y(2)) to (x(3), y(3)) and so on to (x(n), y (n)). This is exactly the same as the Draw.FillPolygon method', 'drawfillpolygon (x, y : array 1 .. * of int, n : int, Color : int)', '(Procedure)', ['x', 'y', 'n', 'Colour'], ['Array of x positions of points on polygon', 'Array of y positions of points on polygon', 'Number of sides on the polygon', 'Polygon fill colour']);
                case 'drawfillstar': return hoverCompletions_1.hover('The drawfillstar procedure is used to draw a filled five pointed star on the screen bounded by a rectangle with bottom left and top right corners of (x1, y1) to (x2, y2) and filled using the specified Color. This is exactly the same as the Draw.FillStar method', 'drawfillstar (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Star fill colour']);
                case 'drawline': return hoverCompletions_1.hover('The drawline procedure is used to draw a line on the screen from (x1, y1) to (x2, y2) using the specified Color. This is exactly the same as the Draw.Line method', 'drawline (x1, y1, x2, y2, Colour : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Line colour']);
                case 'drawmapleleaf': return hoverCompletions_1.hover('The drawmapleleaf procedure is used to draw a maple leaf on the screen bounded by a rectangle described by the bottom left and top right corners of (x1, y1) to (x2, y2) using the specified Color. This is exactly the same as the Draw.MapleLeaf method', 'drawmapleleaf (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Maple leaf colour']);
                case 'drawoval': return hoverCompletions_1.hover('The drawoval procedure is used to draw an oval whose center is at (x, y). The horizontal and vertical distances from the center to the oval are given by xRadius and yRadius. This is exactly the same as the Draw.Oval method', 'drawoval (x, y, xRadius, yRadius, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Oval colour']);
                case 'drawpolygon': return hoverCompletions_1.hover('The drawpolygon procedure is used to draw a polygon with n points. A line is drawn in Color from the point (x(1), y(1)) to (x(2), y(2)) to (x(3), y(3)) and so on. This is exactly the same as the Draw.Polygon method', 'drawpolygon (x, y : array 1 .. * of int, n : int, Color : int)', '(Procedure)', ['x', 'y', 'n', 'Colour'], ['Array of x positions of points on polygon', 'Array of y positions of points on polygon', 'Number of sides on the polygon', 'Polygon colour']);
                case 'drawstar': return hoverCompletions_1.hover('The drawstar procedure is used to draw a star on the screen bounded by a rectangle described by the bottom left and top right corners of (x1, y1) to (x2, y2) using the specified Color. This is exactly the same as the Draw.Star method', 'drawstar (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Star colour']);
                case 'empty': return hoverCompletions_1.hover('The empty function is used in a concurrent program. It returns true if the variableReference, which must be a condition variable, has no processes waiting for it. Processes join the queue of a condition variable by executing the wait statement, and are awakened by the signal statement', 'empty (variableReference) : boolean', '(Function)', ['variableReference'], ['Input variable to check'], 'If variable has a process waiting for it');
                case 'eof': return hoverCompletions_1.hover('The eof (end of file) function is used to determine if there is any more input. It returns true when there are no more characters to be read', 'eof (streamNumber : int) : boolean', '(Function)', ['streamNumber'], ['Id of a file stream'], 'If all data has been read from stream');
                case 'erealstr': return hoverCompletions_1.hover('The erealstr function is used to convert a real number to a string. erealstr always converts to scientific notation', 'erealstr (r : real, width, fractionWidth, exponentWidth : int) : string', '(Function)', ['r', 'width', 'fractionWidth', 'exponentWidth'], ['Input real number to convert', 'Min width of final result', 'Width of fraction', 'Min width of exponent'], '');
                case 'exp': return hoverCompletions_1.hover('The exp function is used to find e to the power `r`, where e is the natural base and r is the parameter to exp. For example, exp (0) returns 1 and exp (1) returns the value of e', 'exp (r : real) : real', '(Function)', ['r'], ['Value to exponentiate'], 'Value of constant e to the power of `r`');
                case 'fetcharg': return hoverCompletions_1.hover('The fetcharg function is used to access the `i`-th argument that has been passed to a program from the command line', 'fetcharg ( i : int ) : string', '(Function)', ['i'], ['Which argument to access'], 'Output string of argument');
                case 'floor': return hoverCompletions_1.hover('Returns the largest integer that is less than or equal to `r`', 'floor ( r : real ) : int', '(Function)', ['r'], ['Input real number to floor'], 'Output floor of `r`');
                case 'frealstr': return hoverCompletions_1.hover('The frealstr function is used to convert a real number to a string. frealstr never converts to scientific notation', 'frealstr ( r : real, width, fractionWidth : int ) : string', '(Function)', ['r', 'width', 'fractionWidth'], ['real number to convert', 'Min width of output', 'Number of fraction digits'], 'Converted string of `r`');
                case 'getch': return hoverCompletions_1.hover('The getch procedure is used to input a single character without waiting for the end of a line. The parameter ch is set to the next character in the keyboard buffer (the oldest not-yet-read character)', 'getch ( var ch : string ( 1 ) )', '(Procedure)', ['ch'], ['Variable set to next keyboard character']);
                case 'getchar': return hoverCompletions_1.hover('The getchar function is used to input a single character without waiting for the end of a line. The next character in the keyboard buffer (the oldest not-yet-read character) is returned', 'getchar : char', '(Function)', [], [], 'next keyboard character');
                case 'getenv': return hoverCompletions_1.hover('The getenv function is used to access the environment string whose name is symbol. These strings are determined by the shell (command processor) or the program that caused your program to run. See also the nargs and fetcharg functions', 'getenv ( symbol : string ) : string', '(Function)', ['symbol'], ['Setting to get'], 'Resulting setting');
                case 'getpid': return hoverCompletions_1.hover('The getpid function is used to determine the I.D. (number) that identifies the current operating system task (process). Beware that there are processes, activated by the fork statement, that are independent of the operating systems tasks', 'getpid : int', '(Function)', [], [], 'Pid of program');
                case 'getpriority': return hoverCompletions_1.hover('The getpriority function returns the priority of an executing process in a concurrent program. A smaller value means a faster speed', 'getpriority : nat', '(Function)', [], [], 'Gets priority of current process');
                case 'hasch': return hoverCompletions_1.hover('The hasch procedure is used to determine if there is a character that has been typed but not yet been read', 'hasch : boolean', '(Function)', [], [], 'If a char has been typed but not read');
                case 'index': return hoverCompletions_1.hover('The index function is used to find the position of patt within string s. For example, index ( "chair", "air" ) is 3', 'index (s , patt : string ) : int', '(Function)', ['s', 'patt'], ['String to search for `patt` in', 'substring to search for in `s`'], 'Index of the start of `patt` in `s`');
                case 'intreal': return hoverCompletions_1.hover('The intreal function is used to convert an integer to a real number. This function is rarely used, because in Turing, an integer value can be used where ever a real value is required. When the integer value is used where a real value is required, the intreal function is implicitly called to do the conversion from int to real', 'intreal ( i : int ) : real', '(Function)', ['i'], ['Integer input to be converted to real'], 'Output real number from `i`');
                case 'intstr': return hoverCompletions_1.hover('The intstr function is used to convert an integer to a string. The string is equivalent to i, padded on the left with blanks as necessary to a length of width, written in the given number base. For example, intstr (14, 4, 10)="bb14" where b represents a blank. The width and base parameters are both optional. If they are omitted, the string is made just long enough to hold the value, and the number base is 10', 'intstr ( i : int [ , width : int [ , base : int ] ] ) : string', '(Function)', ['i', 'width', 'base'], ['Integer to be converted', '_(Optional)_ Width of output string', '_(Optional)_ base of output'], 'Output string');
                case 'length': return hoverCompletions_1.hover('The length function returns the number of characters in the string. The string must be initialized. For example, length("table") is 5', 'length ( s : string ) : int', '(Function)', ['s'], ['Input string'], 'Length of input string `s`');
                case 'ln': return hoverCompletions_1.hover('The ln function is used to find the natural logarithm (base e) of a number. For example, ln ( 1) is 0', 'ln ( r : real ) : real', '(Function)', ['r'], ['Input real number'], 'Natural logarithm of `r`');
                case 'locate': return hoverCompletions_1.hover('The locate procedure is used to move the cursor so that the next output from put will be at the given row and column. Row 1 is the top of the screen and column 1 is the left side of the screen', 'locate ( row, column : int )', '(Procedure)', ['x', 'y'], ['X position to set curser to', 'Y position to set curser to']);
                case 'locatexy': return hoverCompletions_1.hover('The locatexy procedure is used to move the cursor so that the next output from put will be at approximately (x, y). The exact location may be somewhat to the left of x and below y to force alignment to a character boundary', 'locatexy ( x , y : int )', '(Procedure)', ['row', 'column'], ['Row to set curser to', 'Column to set curser to']);
                case 'lower': return hoverCompletions_1.hover('The lower attribute is used to find the lower bound of an array, string, char(n) or non-opaque subrange type. Since the lower bound is necessarily known at compile time, lower is rarely used', 'lower (reference [ , dimension ] ) : int', '(Function)', ['reference', 'dimension'], ['Input reference array', '_(Optional)_ Dimension to check'], 'Lower bound of array');
                case 'max': return hoverCompletions_1.hover('The max function is used to find the maximum of two numbers (the two expn\'s). For example, max ( 5, 7 ) is 7. If both numbers are int, the result is int. If both numbers are nat (natural numbers), the result is nat. But if one or both of the numbers are real, the result is real', 'max ( expn , expn ) : expn', '(Function)', ['expn', 'expn'], ['Expression 1', 'Expression 2'], 'Larger of the two input expressions');
                case 'min': return hoverCompletions_1.hover('The min function is used to find the minimum of two numbers (the two expn\'s). For example, min ( 5, 7 ) is 5. If both numbers are int, the result is int. If both numbers are nat (natural numbers), the result is nat. But if one or both of the numbers are real, the result is real', 'min ( expn , expn ) : expn', '(Function)', ['expn', 'expn'], ['Expression 1', 'Expression 2'], 'Smaller of the two input expressions');
                case 'natreal': return hoverCompletions_1.hover('The natreal function is used to convert a natural number to a real number. This function is rarely used, because in Turing, a natural number can be used anyplace a real value is required. When this is done, the natreal function is implicitly called to do the conversion from nat to real. The natreal function is similar to intreal, except that natreal handles values that are larger than int values and does not handle negative values', 'natreal ( n : nat ) : real', '(Function)', ['n'], ['Input natural number'], 'Output real number from input `n`');
                case 'natstr': return hoverCompletions_1.hover('The natstr function is used to convert a natural number to a string. The string is equivalent to n, padded on the left with blanks as necessary to a length of width, written in the given number base. For example, natstr (14, 4, 10)="bb14" where b represents a blank', 'natstr ( n : nat [ , width : int [, base : int ] ] ) : string', '(Function)', ['n', 'width', 'base'], ['Input natural number', '_(Optional)_ Min width of string', '_(Optional)_ Output base'], 'Converted string');
                case 'ord': return hoverCompletions_1.hover('The ord function accepts an enumerated value, char, or a string of length 1, and returns the position of the value in the enumeration, or of the character in the ASCII (or EBCDIC for IBM mainframes) sequence. Values of an enumerated type are numbered left to right starting at zero. For example, ord ( "A" ) is 65. The ord function is the inverse of chr, so for any character c, chr ( ord (c)) = c', 'ord ( ch : char ) : int', '(Function)', ['ch'], ['Input character'], 'Ascii code for input `ch`');
                case 'play': return hoverCompletions_1.hover('The play procedure is used to sound musical notes on the computer', 'play ( music : string )', '(Procedure)', ['music'], ['String of notes to play']);
                case 'pred': return hoverCompletions_1.hover('The pred function accepts an integer, character, or an enumerated value and returns the integer minus one, the previous character, or the previous value in the enumeration. For example, pred ( 7 ) is 6', 'pred( expn ) : expn', '(Function)', ['expn'], ['Input enumerated value'], 'Output previous enumberated value');
                case 'rand': return hoverCompletions_1.hover('The rand statement is used to create a pseudo-random number in the range zero to one. For example, if x is a real number, after rand(x), x would have a value such as 0.729548 or 0.352879', 'rand (var r : real)', '(Procedure)', ['r'], ['Variable set to random value between 0 and 1']);
                case 'randint': return hoverCompletions_1.hover('The randint statement is used to create a pseudo-random integer in the range low to high, inclusive. For example, if i is an integer, after randint(i,1, 10), i would have a value such as 7 or 2 or 10', 'randint ( var i : int, low, high : int )', '(Function)', ['i', 'low', 'high'], ['Variable set to random number between `low` and `high`', 'lower bound of output', 'higher bound of output'], '');
                case 'randnext': return hoverCompletions_1.hover('The randnext procedure is used when you need several sequences of pseudo-random numbers, and you need to be able to exactly repeat these sequences for a number of simulations. The Rand.Next procedure is the same as rand, except seq specifies one of ten independent and repeatable sequences of pseudo-random real numbers', 'randnext ( var v : real, seq : 1 .. 10 )', '(Procedure)', ['v', 'seq'], ['Variabled set to random number', 'Input sequence']);
                case 'randseed': return hoverCompletions_1.hover('The randseed procedure restarts one of the sequences generated by Rand.Next. Each restart with the same seed causes Rand.Next to produce the same sequence for the given sequence', 'randseed ( seed : int, seq : 1 .. 10 )', '(Procedure)', ['seed', 'seq'], ['Seed to start sequence at', 'Input sequence']);
                case 'realstr': return hoverCompletions_1.hover('The realstr function is used to convert a real number to a string. For example, realstr (2.5e1, 4)="bb25" where b represents a blank. The string is an approximation to r, padded on the left with blanks as necessary to a length of width', 'realstr ( r : real, width : int ) : string', '(Function)', ['r', 'width'], ['Input real number', 'Min width of output string'], 'Output string from `r`');
                case 'repeat': return hoverCompletions_1.hover('The repeat function returns i copies of string s catenated together. For example, repeat ("X", 4) is XXXX', 'repeat ( s : string, i : int ) : string', '(Function)', ['s', 'i'], ['String to be repeated', 'Number of times to repeat string `i`'], 'Output string');
                case 'round': return hoverCompletions_1.hover('The round function is used to convert a real number to an integer. The result is the nearest integer to r. In the case of a tie, the numerically larger value is returned. For example, round (3) is 3, round (2.85) is 3 and round (-8.43) is -8', 'round ( r : real ) : int', '(Function)', ['r'], ['Input real number'], 'Output rounded `r`');
                case 'setpriority': return hoverCompletions_1.hover('The setpriority procedure is used to set the priority of a process in a concurrent program. This priority cannot be counted on to guarantee critical access to shared variables. A smaller value of p means increased speed. The argument to setpriority may be limited to the range 0 to 2**15 - 1', 'setpriority ( p : nat )', '(Procedure)', ['p'], ['Priority (0-2^14)']);
                case 'setscreen': return hoverCompletions_1.hover('The setscreen statement is used to change the mode of the screen, as well as the way in which Turing does input and output. The parameter to setscreen is a string, such as "graphics". The string contains one or more options separated by commas, such as "text, noecho"', 'setscreen ( s : string )', '(Procedure)', ['s'], ['Screen mode']);
                case 'sign': return hoverCompletions_1.hover('The sign function is used to determine whether a number is positive, zero or negative. It returns 1 if r > 0, 0 if r = 0, and -1 if r < 0. For example, sign (5) is 1 and sign (-23) is -1', 'sign ( r : real ) : -1 .. 1', '(Function)', ['r'], ['Input number'], 'Sign of input number `r`');
                case 'sind': return hoverCompletions_1.hover('The sind function is used to find the sine of an angle given in degrees. For example, sind (0) is 0', 'sind ( r : real ) : real', '(Function)', ['r'], ['Input angle (degrees)'], 'Output trig ratio');
                case 'sin': return hoverCompletions_1.hover('The sin function is used to find the sine of an angle given in radians. For example, sin (0) is 0', 'sin ( r : real ) : real', '(Function)', ['r'], ['Input angle (radians)'], 'Output trig ratio');
                case 'sizeof': return hoverCompletions_1.hover('The sizeof attribute is used to find the number of bytes used to represent the type or variable. This is implementation-dependent (dirty)', 'sizeof (typeNameOrVariableReference) : nat', '(Function)', ['typeNameOrVariableReference'], ['Input variable to find size of'], 'Bytes that `typeNameOrVariableReference` takes up');
                case 'sound': return hoverCompletions_1.hover('The sound procedure is used to cause the computer to sound a note of a given frequency for a given time. The frequency is in cycles per second (Hertz). The time duration is in milliseconds. For example, middle A on a piano is 440 Hertz, so sound(440, 1000) plays middle A for one second', 'sound ( frequency, duration : int )', '(Procedure)', ['frequency', 'duration'], ['Frequency of sound to play', 'Duration to play frequency']);
                case 'sqrt': return hoverCompletions_1.hover('The sqrt function is used to find the square root of a number. For example, sqrt (4) is 2', 'sqrt ( r : real ) : real', '(Function)', ['r'], ['Input real number'], 'Square root of `r`');
                case 'strint': return hoverCompletions_1.hover('The strint function is used to convert a string to an integer. The integer is equivalent to string s. The number base parameter is optional, for example, strint ("47") = 47. In Turing proper, the base is not allowed and is assumed to be 10', 'strint ( s : string [ , base : int ] ) : int', '(Function)', ['s', 'base'], ['Input string', '_(Optional)_ Base of input string `s`'], 'Output integer from string `s`');
                case 'strintok': return hoverCompletions_1.hover('The strintok function is used determine whether the strint function can be used to convert the string to an integer without causing an error. If the string can be successfully converted, then strintok returns true, otherwise it returns false', 'strintok ( s : string [ , base : int ] ) : boolean', '(Function)', ['s', 'base'], ['Input string', '_(Optional)_ Base of input string `s`'], 'If string `s` base `base` can be represented as an integer');
                case 'strnat': return hoverCompletions_1.hover('The strnat function is used to convert a string to a natural number. The natural number is equivalent to string s. The number base parameter is optional, for example, strnat("47") = 47', 'strnat ( s : string [ , base : int ] ) : nat', '(Function)', ['s', 'base'], ['Input string', '_(Optional)_ Base of input string `s`'], 'Output natural number from string `s`');
                case 'strnatok': return hoverCompletions_1.hover('The strnatok function is used determine whether the strnat function can be used to convert the string to a natural number without causing an error. If the string can be successfully converted, then strnatok returns true, otherwise it returns false', 'strnatok ( s : string [ , base : int ] ) : boolean', '(Function)', ['s', 'base'], ['Input string', '_(Optional)_ Base of input string `s`'], 'If string `s` base `base` can be represented as a natural number');
                case 'strreal': return hoverCompletions_1.hover('The strreal function is used to convert a string to a real number. For example, strreal ("2.5e1") will produce an approximation to the number 25.0', 'strreal ( s : string ) : real', '(Function)', ['s'], ['Input string to convert'], 'Output real number from string `s`');
                case 'strrealok': return hoverCompletions_1.hover('The strrealok function is used determine whether the strreal function can be used to convert the string to a real number without causing an error. If the string can be successfully converted, then strrealok returns true, otherwise it returns false', 'strrealok ( s : string ) : boolean', '(Function)', ['s'], ['Input string to convert'], 'If string `s` can be represented as a real number');
                case 'succ': return hoverCompletions_1.hover('The succ function accepts an integer, character or an enumerated value and returns the integer plus one, the next character, or the next value in the enumeration. For example, succ (7) is 8.', 'succ ( expn ) : expn', '(Function)', ['expn'], ['Input enumerated value'], 'Output previous enumberated value');
                case 'sysclock': return hoverCompletions_1.hover('The sysclock statement is used on a multitasking system such as UNIX to determine the amount of time that has been used by this program (process). Variable c is assigned the number of central processor milliseconds assigned to this program. This is of little use on a personal computer, where sysclock returns the same value as clock', 'sysclock ( var c : int )', '(Procedure)', ['c'], ['Variable `c` set to ms of cpu time used']);
                case 'system': return hoverCompletions_1.hover('The system statement is used to execute the shell (operating system) command, as if it were typed at the terminal. The return code is in ret. A return code of 0 (zero) means no detected errors. A return code of 127 means the command processor could not be accessed. A return code of 126 means the command processor did not have room to run on the PC', 'system ( command : string, var ret : int )', '(Procedure)', ['command', 'ret'], ['Command to be executed', 'Variable set to return code']);
                case 'tand': return hoverCompletions_1.hover('The tand function is used to find the tangent of an angle given in degrees. For example, tand (45) is 1', 'tand ( r : real ) : real', '(Function)', ['r'], ['Input angle (degrees)'], 'Output trig ratio');
                case 'tan': return hoverCompletions_1.hover('The tan function is used to find the tangent of an angle given in radians. For example, tan (p/4) is 0.5', 'tan ( r : real ) : real', '(Function)', ['r'], ['Input angle (degrees)'], 'Output trig ratio');
                case 'time': return hoverCompletions_1.hover('The time statement is used to determine the current time of day. Variable t is assigned a string in the format "hh:mm:ss". For example, if the time is two minutes and 47 seconds after nine A.M., t will be set to "09:02:47". Twenty-four hour time is used. For example, eleven thirty P.M. gives the string "23:30:00"', 'time ( var t : string )', '(Procedure)', ['t'], ['Variable `t` set to current time']);
                case 'upper': return hoverCompletions_1.hover('The upper attribute is used to find the upper bound of an array, string, char(n) or non-opaque subrange type', 'upper ( reference [ , dimension ] ) : int', '(Function)', ['reference', 'dimension'], ['Input reference array', '_(Optional)_ Dimension to check'], 'Upper bound of array');
                case 'wallclock': return hoverCompletions_1.hover('The wallclock statement is used to determine the time in seconds since 00:00:00 GMT (Greenwich Mean Time) January 1, 1970', 'wallclock ( var c : int )', '(Procedure)', ['c'], ['Variable set to seconds since Jan 1, 1970']);
                case 'whatdotcolour': return hoverCompletions_1.hover('The whatdotcolour function is used to determine the colour number of the specified pixel', 'whatdotcolor ( x, y : int ) : int', '(Function)', ['x', 'y'], ['X position to check', 'Y position to check'], 'Colour id at position `x`, `y`');
            }
        }
    }
});
exports.keywordHoverProvider = vscode.languages.registerHoverProvider('t', {
    provideHover(doc, pos) {
        const range = doc.getWordRangeAtPosition(pos, hoverCompletions_1.keywordRegex); // Get words based on keywords
        const word = doc.getText(range); // get that word
        const numRange = doc.getWordRangeAtPosition(pos, hoverCompletions_1.numberRegex); // Get words based on if theyre a number
        const stringRange = doc.getWordRangeAtPosition(pos, hoverCompletions_1.stringRegex); // Get words based on if theyre a string
        if (stringRange) { // Hovering on string
            return hoverCompletions_1.hover('Strings store word information. These can be used to store any data with and can be parsed to other datatypes', doc.getText(stringRange) + ' : string', '(Value)');
        }
        else if (numRange) { // Hovering on number
            const num = doc.getText(numRange);
            const code = (num + ' : ' + (num.includes('.') ? 'real' : (Number(num) < 0 ? 'int' : 'nat')));
            return hoverCompletions_1.hover('Numbers store numeric information. There are 3 main datatypes. Either real which can contain decimals, integer which can contain all positive and negative numbers, and nat. Natural numbers are only positive and do include 0', code, '(Value)');
        }
        else if (range) { // Got a keyword
            switch (word) { // Find match
                case 'int': return hoverCompletions_1.hover('The int (integer) type has the values … 2, 1, 0, 1, 2 … Integers can be combined by various operators such as addition (+) and multiplication (*). Integers can also be combined with real numbers, in which case the result is generally a real number. An integer can always be assigned to a real variable, with implicit conversion to real', 'int', '(Datatype)');
                case 'real': return hoverCompletions_1.hover('The real number type is used for numbers that have fractional parts, for example, 3.14159. Real numbers can be combined by various operators such as addition (+) and multiplication (*). Real numbers can also be combined with integers (whole numbers, such as 23, 0 and -9), in which case the result is generally a real number. An integer can always be assigned to a real variable, with implicit conversion to real', 'real', '(Datatype)');
                case 'string': return hoverCompletions_1.hover('Each variable whose type is a stringType can contain a sequence (a string ) of characters. The length of this sequence must not exceed the stringType\'s maximum length', 'string', '(Datatype)');
                case 'boolean': return hoverCompletions_1.hover('The boolean type is used for values that are either true or false. These true-false values can be combined by various operators such as or and and', 'boolean', '(Datatype)');
                case 'nat': return hoverCompletions_1.hover('The nat (natural number) type has the values 0, 1, 2, 3 … Natural numbers can be combined by various operators, such as addition (+) and multiplication (*). Natural numbers can be combined with integers (type int), in which case the result is an integer. Natural numbers can also be combined with real numbers, in which case the result is generally a real number. Natural numbers can always be assigned to real variables, with implicit conversion to real', 'nat', '(Datatype)');
                case 'char': return hoverCompletions_1.hover('Each variable whose type is a char contains a single character, such as the letter A, the digit 3 or the special character &', 'char', '(Datatype)');
                case 'pointer': return hoverCompletions_1.hover('A variable declared as a pointer type is used to locate an element of a collection or class or a value of a type. The new statement creates a new element (or value) and places the element\'s location in a pointer variable. The free statement destroys an element located by a pointer variable', 'pointer', '(Datatype)');
                case 'array': return hoverCompletions_1.hover('An array consists of a number of elements. The typeSpec gives the type of these elements. There is one element for each item in the (combinations of) range(s) of the indexType(s). In the following example, the array called marks consists of 100 elements, each of which is an integer', 'array', '(Datatype)');
                case 'var': return hoverCompletions_1.hover('An assignment statement calculates the value of the expression', 'var', '(Keyword)');
                case 'const': return hoverCompletions_1.hover('An assignment statement calculates the value of the expression', 'const', '(Keyword)');
                case 'assert': return hoverCompletions_1.hover('An assert statement is used to make sure that a certain requirement is met. This requirement is given by the trueFalseExpn. The trueFalseExpn is evaluated. If it is true, all is well and execution continues. If it is false, execution is terminated with an appropriate message', 'assert', '(Keyword)');
                case 'bind': return hoverCompletions_1.hover('The bind declaration creates a new name (or names) for a variable reference (or references). You are allowed to change the named item only if you specify var. You can also bind to named non scalar constants', 'bind', '(Keyword)');
                case 'break': return hoverCompletions_1.hover('On systems with a debugger, the environment "pauses" when execution reaches the break statement. While "pausing" is environment specific, in general, the program stops execution until the user presses the "Resume" or "Continue" button. While paused, the program variables can be inspected, stack traces done, etc', 'break', '(Keyword)');
                case 'case': return hoverCompletions_1.hover('A case statement is used to choose among a set of statements (and declarations). One set is chosen and executed and then execution continues just beyond end case', 'case', '(Statement)');
                case 'class': return hoverCompletions_1.hover('A class declaration defines a template for a package of variables, constants, types, subprograms, etc. The name of the class (id) is given in two places, just after class and just after end. Items declared inside the class can be accessed outside of the class only if they are exported', 'class', '(Keyword)');
                case 'close': return hoverCompletions_1.hover('In Turing, files are read and written using a fileNumber. In most cases, this number is given a value using the open statement, which translates a file name, such as "Master", to a file number, such as 5. When the program is finished using the file, it disconnects from the file using the close statement', 'close', '(Keyword)');
                case 'end': return hoverCompletions_1.hover('Ends a control statement', 'end', '(Statement)');
                case 'deferred': return hoverCompletions_1.hover('A procedure or function is declared to be deferred when you want to be able to override the subprogram in an expansion. The procedure or function must be in a module, monitor or class', 'deferred', '(Keyword)');
                case 'exit': return hoverCompletions_1.hover('An exit statement is used to stop the execution of a loop or for statement. Form (a) is the most common. Here, the true/false expression is evaluated. If it is true, the loop is terminated and execution jumps down and continues just beyond end loop or end for. If it is false, the loop keeps on repeating. Form (b) always causes the loop to terminate. This form is almost always used inside another conditional statement such as if', 'exit', '(Statement)');
                case 'export': return hoverCompletions_1.hover('An export list is used to specify those items declared in a module, monitor or class that can be used outside of it. Items that are declared inside a module, monitor or class but not exported cannot be accessed outside of it', 'export', '(Statement)');
                case 'true': return hoverCompletions_1.hover('A boolean (true/false) variable can be either true or false (see boolean type)', 'true : boolean', '(Value)');
                case 'false': return hoverCompletions_1.hover('A boolean (true/false) variable can be either true or false (see boolean type)', 'false : boolean', '(Value)');
                case 'flexible': return hoverCompletions_1.hover('The flexible keyword allows an array to be resized using new at a later point in time. The indices may have compile-time or run-time upper bounds (the lower bound must be compile-time)', 'flexible', '(Keyword)');
                case 'for': return hoverCompletions_1.hover('The statements and declarations in a for statement are repeatedly executed. In the first iteration, the identifier is assigned the value of first. With each additional iteration, the identifier increases by 1 (or by increment, if the by clause is present). The loop stops executing when adding 1 (or increment) to the identifier would cause the identifier to exceed last. first and last must be integer values (or else enumerated or char values). If you specify decreasing, then the identifier decreases by 1 (or by increment) each time through', 'for', '(Loop)');
                case 'forward': return hoverCompletions_1.hover('A procedure or function is declared to be forward when you want to define its header but not its body. This is the case when one procedure or function calls another, which in turn calls the first; this situation is called mutual recursion. The use of forward is necessary in this case, because every item must be declared before it can be used', 'forward', '(Keyword)');
                case 'free': return hoverCompletions_1.hover('A free statement destroys (deallocates) an element that has been allocated by a new statement', 'free', '(Keyword)');
                case 'fcn': // Will keep going til a break/return
                case 'function': return hoverCompletions_1.hover('A function declaration creates (but does not run) a new function. The name of the function (id) is given in two places, just after function and just after end', 'function', '(Keyword)');
                case 'get': return hoverCompletions_1.hover('The get statement inputs each of the getItems. Ordinarily, the output comes from the keyboard. However, if the streamNumber is present, the input comes from the file specified by the stream number (see the open statement for details). Also, input can be redirected so it is taken from a file rather than the keyboard. Check the documentation on the environment for instructions on doing so', 'get', '(Statement)');
                case 'handler': return hoverCompletions_1.hover('An exception handler is an optional block of statements and declarations in a subprogram (or process). It is activated when the program (or process) fails. This occurs, for example when dividing by zero', 'handler', '(Statement)');
                case 'if': return hoverCompletions_1.hover('An if statement is used to choose among a set of statements (and declarations). One set (at most) is chosen and executed and then execution continues just beyond end if', 'if', '(Statement)');
                case 'else': return hoverCompletions_1.hover('An else statement is used to run code after all if and elsif blocks have evaluated to be false', 'else', '(Statement)');
                case 'elsif': return hoverCompletions_1.hover('An elsif statement is used to check another condition after previous if or elsif blocks have evaluated to be false', 'elsif', '(Statement)');
                case 'by': return hoverCompletions_1.hover('An implement-by clause is used to specify that a module, monitor or class C is to be automatically implemented by the implementByItem. C is called the interface and the implementByItem, which must contain an implement clause, is called the implementation. See implement clause for details and an example', 'by', '(Keyword)');
                case 'implement': return hoverCompletions_1.hover('An implement clause is used to specify that the module, monitor or class containing the clause is to be the implementation of another module, monitor or class. This implementation is a special kind of expansion. The module, monitor or class containing the clause gains access to (inherits) all the declarations inside the target item', 'implement', '(Keyword)');
                case 'import': return hoverCompletions_1.hover('An import list is used to specify those items that a procedure, function, module, monitor, or a class uses from outside of itself. Note that a function or procedure is not allowed to have an import list and thus automatically imports whichever functions or procedures are used by the function or procedure. The compiler determines the list automatically by looking to see what items are actually used', 'import', '(Statement)');
                case 'inherit': return hoverCompletions_1.hover('An inherit clause specifies that the class containing the clause is to be an expansion of another class. This expansion is called inheritance. The class containing the clause gains access to (inherits) all the declarations inside the target item. Expansions are used to add new declarations and exports and to support polymorphism (overriding subprograms)', 'inherit', '(Keyword)');
                case 'loop': return hoverCompletions_1.hover('A loop statement causes the statements (and declarations) in it to be repeatedly executed. This continues until terminated by one of its enclosed exit statements (or by an enclosed return or result statement)', 'loop', '(Loop)');
                case 'monitor': return hoverCompletions_1.hover('A monitor is a special purpose module (see module) that is used with concurrent processes (see process). At most, one concurrent process (see process) can be active in a monitor at a time. This means that a process will be blocked if it calls a monitor that is already active. The process will not be allowed to proceed until the monitor is inactive. The monitor provides mutually exclusive access to the monitor\'s internal data', 'monitor', '(Keyword)');
                case 'module': return hoverCompletions_1.hover('A module declaration creates a package of variables, constants, types, subprograms, etc. The name of the module (id) is given in two places, just after module and just after end. Items declared inside the module can be accessed outside of the module only if they are exported. Items from outside the module that are to be used in the module need to be imported (unless they are predefined or pervasive)', 'module', '(Keyword)');
                case 'new': return hoverCompletions_1.hover('A new statement creates (allocates) a new element and assigns its location to the pointer variable. This element can be an object of a collection or class or a value of a type. If the collectionOrClassId is omitted, the choice of element is determined by the type of the pointer. For example, if the pointer is to class C, an object of class C will be allocated', 'new', '(Keyword)');
                case 'nil': return hoverCompletions_1.hover('The nil pointer does not locate any element (object). Pointers locate items in collections, classes and types. The collectionOrClassId is optional', 'nil', '(Value)');
                case 'open': return hoverCompletions_1.hover('The open statement connects the program to a file so the program can perform operations such as read on the file. In form (a), the open statement translates a fileName, such as "Master", to a file number such as 5. Form (b), which is less-commonly used, opens a file whose name is given by a program argument. This is described below', 'open', '(Keyword)');
                case 'pervasive': return hoverCompletions_1.hover('When a variable, constant, type or subprogram is declared, you can specify that it is to be pervasive, which means that it does not need to be explicitly imported into modules, monitors or classes in the current scope. The keyword pervasive can be abbreviated as an asterisk (*)', 'pervasive', '(Keyword)');
                case 'post': return hoverCompletions_1.hover('A post assertion is a special form of an assert statement that is used in a procedure or function. It is used to give requirements that the body of the procedure or function is supposed to satisfy. These requirements are given by the trueFalseExpn. After the body has executed and just before the procedure or function returns, the trueFalseExpn is evaluated. If it is true, all is well and execution continues. If it is false, execution is terminated with an appropriate message. See assert statements and procedure and function declarations for more details. See also pre and invariant assertions', 'post', '(Keyword)');
                case 'pre': return hoverCompletions_1.hover('A pre assertion is a special form of an assert statement that is used at the beginning of a procedure or function. It is used to give requirements that the caller of the procedure or functions is supposed to satisfy. These requirements are given by the trueFalseExpn. The trueFalseExpn is evaluated. If it is true, all is well and execution continues. If it is false, execution is terminated with an appropriate message. See assert statements and procedure and function declarations for more details. See also post and invariant assertions', 'pre', '(Keyword)');
                case 'proc': // Will keep going til a break/return
                case 'procedure': return hoverCompletions_1.hover('A procedure declaration creates (but does not run) a new procedure. The name of the procedure (id) is given in two places, just after procedure and just after end', 'procedure', '(Keyword)');
                case 'put': return hoverCompletions_1.hover('The put statement outputs each of the putItems. Usually, a new line is started in the output after the final putItem. If the optional dot-dot (..) is present, though, subsequent output will be continued on the current output line. With character graphics, the omission of dot-dot causes the remainder of the output line to be cleared to blanks', 'put', '(Statement)');
                case 'quit': return hoverCompletions_1.hover('The quit statement causes a program (or concurrent process) to fail. The failure (called an exception) either aborts the program (or process) or causes control to be passed to an exception handler', 'quit', '(Keyword)');
                case 'read': return hoverCompletions_1.hover('The read statement inputs each of the readItems from the specified file. These items are input directly using the binary format that they have on the file. In other words, the items are not in source (ASCII or EBCDIC) format. In the common case, these items have been output to the file using the write statement', 'read', '(Keyword)');
                case 'result': return hoverCompletions_1.hover('A result statement, which must appear only in a function, is used to provide the value of the function', 'result', '(Statement)');
                case 'return': return hoverCompletions_1.hover('A return statement terminates the procedure (or main program) in which it appears. Ordinarily, a procedure (or main program) terminates by reaching its end; the return statement is used to cause early termination', 'return', '(Statement)');
                case 'self': return hoverCompletions_1.hover('The self function produces a pointer to the current object. This function can be used only inside a class declaration. See class', 'self', '(Keyword)');
                case 'to': return hoverCompletions_1.hover('Used when creating pointers to user defined classes. Also used when binding a variable to another reference variable', 'to', '(Keyword)');
                case 'unit': return hoverCompletions_1.hover('A program can be divided up into units, each in a separate file. All of these files except the main program begin with the keyword unit. The unit contains the main program, a module, a monitor or a class', 'unit', '(Keyword)');
                case 'unqualified': return hoverCompletions_1.hover('When an identifier x is exported from a module, monitor or class M using the keyword unqualified, it can be used outside of M without the qualification "M.". In other words, outside of M, it can be referred to as simply x', 'unqualified', '(Keyword)');
                case 'of': return hoverCompletions_1.hover('Used in declaring arrays, the of keyword determines the datatype of the contents of an array', 'of', '(Keyword)');
                case 'label': return hoverCompletions_1.hover('Label is used in case statements where it gives a possible state. Multiple state can be separated by a comma and none can be given for a default value', 'label', '(Keyword)');
            }
        }
    }
});
exports.moduleHoverProvider = vscode.languages.registerHoverProvider('t', {
    provideHover(doc, pos) {
        const subRange = doc.getWordRangeAtPosition(pos, hoverCompletions_1.moduleSubRegex); // Get words based on module functions
        const range = doc.getWordRangeAtPosition(pos, hoverCompletions_1.moduleRegex); // Get words based on modules
        const sWord = doc.getText(subRange); // Get that word
        const word = doc.getText(range); // Get that word
        const line = doc.lineAt(pos).text; // Get hovered line
        // Match Modules and their methods
        if (line.search(/(?<=Config.)(Display|Lang|Machine)/) >= 0) {
            switch (sWord) {
                case 'Display': return hoverCompletions_1.hover('Config.Display returns information about the display (or displays) attached to the computer. The parameter displayCode determines what sort of information is passed back', 'Config.Display (displayCode : int) : int', '(Function)', ['displayCode'], ['Info to return. Either: cdScreenHeight, cdScreenWidth, cdMaxNumColors, or cdMaxNumColours'], 'Information about the display');
                case 'Lang': return hoverCompletions_1.hover('Config.Lang returns information about the language and the limitations of the implementation that the program is currently running. The parameter langCode determines what sort of information is passed back', 'Config.Lang (langCode : int) : int', '(Function)', ['langCode'], ['Info to return. Either: clRelease, clLanguageVersion, clMaxNumStreams, clMaxNumDirStreams, clMaxNumRunTimeArgs'], 'Information about the Turing');
                case 'Machine': return hoverCompletions_1.hover('Config.Machine returns information about the machine that the program is currently running on. The parameter machineCode determines what sort of information is passed back', 'Config.Machine (machineCode : int) : int', '(Function)', ['machineCode'], ['Info to return. Either: cmProcessor, cmFPU, or cmOS'], 'Information on the current machine');
            }
        }
        else if (line.search(/(?<=Dir.)(Open|GetLong|Get|Close|Create|Delete|Change|Current|Exists)/) >= 0) {
            switch (sWord) {
                case 'Change': return hoverCompletions_1.hover('Dir.Change changes the execution directory to that specified by the parameter directoryPathName. This is the equivalent of doing a cd in UNIX', 'Dir.Change (directoryPathName : string)', '(Procedure)', ['directoryPathName'], ['Path to directory to change into']);
                case 'Close': return hoverCompletions_1.hover('Dir.Close is part of a series of four subprograms that help users get directory listings. Dir.Close is used to close a directory stream number opened by Dir.Open. After the directory stream number is closed, it can not be used with Dir.Get or Dir.GetLong', 'Dir.Close (streamNumber : int)', '(Procedure)', ['streamNumber'], ['File stream id']);
                case 'Create': return hoverCompletions_1.hover('Dir.Create is used to create the directory specified by the parameter directoryPathName. This is the equivalent of doing a mkdir in DOS or UNIX', 'Dir.Create (directoryPathName : string)', '(Procedure)', ['directoryPathName'], ['Path to directory to change into']);
                case 'Current': return hoverCompletions_1.hover('Dir.Current returns the full path name of the current execution directory. This is the equivalent of doing a pwd in UNIX', 'Dir.Current : string', '(Constant)', [], [], 'Current directory');
                case 'Delete': return hoverCompletions_1.hover('Dir.Delete is used to delete the directory specified by the parameter directoryPathName. This is the equivalent of doing a rmdir in DOS or UNIX. Dir.Delete will fail if it attempts delete a directory that has files in it', 'Dir.Delete (directoryPathName : string)', '(Procedure)', ['directoryPathName'], ['Path to directory to change into']);
                case 'Exists': return hoverCompletions_1.hover('Dir.Exists returns true if a directory by the name of directoryPathName exists. It will return false if directoryPathName is a file', 'Dir.Exists (directoryPathName : string) : boolean', '(Function)', ['directoryPathName'], ['Path to directory to change into'], 'If path exists');
                case 'Get': return hoverCompletions_1.hover('Dir.Get is part of a series of four subprograms that help users get directory listings. Dir.Get is used to get the file names in the directory. Each time the function is called, it returns the next file name in the directory', 'Dir.Get (streamNumber : int) : string', '(Function)', ['streamNumber'], ['File stream id'], 'A file in the current streamNumber directory');
                case 'GetLong': return hoverCompletions_1.hover('Dir.GetLong is part of a series of four subprograms that help users get directory listings. Dir.GetLong is used to get the names and assorted information of the files in the directory. Each time the function is called, it returns the name and information of the next file in the directory', 'Dir.GetLong (streamNumber : int, entryName : string, size, attribute, fileTime : int)', '(Procedure)', ['streamNumber', 'entryName', 'size', 'attribute', 'fileTime'], ['File stream id', 'Name of file', 'Size of file', 'File attributes', 'Last file modification']);
                case 'Open': return hoverCompletions_1.hover('Dir.Open is part of a series of four subprograms that help users get directory listings. Dir.Open returns a directory stream number if the directory could be opened', 'Dir.Open (directoryPathName : string) : int', '(Function)', ['directoryPathName'], ['Path to directory to change into'], 'Stream number id');
            }
        }
        else if (line.search(/(?<=Draw.)(Cls|Dot|DashedLine|ThickLine|Line|FillBox|Box|FillOval|Oval|FillArc|Arc|FillPolygon|Polygon|FillMapleLeaf|MapleLeaf|FillStar|Star|Fill|Text)/) >= 0) {
            switch (sWord) {
                case 'Cls': return hoverCompletions_1.hover('The Draw.Cls (clear screen) procedure is used to blank the output window. The cursor is set to the top left (to row 1, column 1)', 'Draw.Cls', '(Procedure)');
                case 'Dot': return hoverCompletions_1.hover('The Draw.Dot procedure is used to color the dot (pixel) at location (x, y) using the specified Color', 'Draw.Dot (x, y, Colour : int)', '(Procedure)', ['x', 'y', 'Colour'], ['X position of dot', 'Y position of dot', 'Colour of dot']);
                case 'Line': return hoverCompletions_1.hover('The Draw.Line procedure is used to draw a line on the screen from (x1, y1) to (x2, y2) using the specified Colour', 'Draw.Line (x1, y1, x2, y2, Colour : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Line colour']);
                case 'DashedLine': return hoverCompletions_1.hover('The Draw.DashedLine procedure is used to draw a dotted or dashed line on the screen from (x1, y1) to (x2, y2) using the specified Color', 'Draw.DashedLine (x1, y1, x2, y2, lineStyle, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'lineStyle', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'drawSolid Draws a solid line (same as Draw.Line) drawDash Draws a dashed line drawDot Draws a dotted line drawDashDot Draws a line that alternates dashes and dots drawDashDotDot Draws a line that alternates dash and dot-dot', 'Line colour']);
                case 'ThickLine': return hoverCompletions_1.hover('The Draw.ThickLine procedure is used to draw a line on the screen from (x1, y1) to (x2, y2) using the specified Color', 'Draw.ThickLine (x1, y1, x2, y2, lineWidth, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'lineWidth', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Width (in pixels) of line', 'Line colour']);
                case 'Box': return hoverCompletions_1.hover('The Draw.Box procedure is used to draw a box on the screen with bottom left and top right corners of (x1, y1) to (x2, y2) using the specified Color', 'Draw.Box (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Box colour']);
                case 'FillBox': return hoverCompletions_1.hover('The Draw.FillBox procedure is used to draw a filled box on the screen with bottom left and top right corners of (x1, y1) to (x2, y2) filled using the specified Color', 'Draw.FillBox (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Start X position', 'Start Y position', 'End X position', 'End Y position', 'Box fill colour']);
                case 'Oval': return hoverCompletions_1.hover('The Draw.Oval procedure is used to draw an oval whose center is at (x, y). The horizontal and vertical distances from the center to the oval are given by xRadius and yRadius', 'Draw.Oval (x, y, xRadius, yRadius, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Oval colour']);
                case 'FillOval': return hoverCompletions_1.hover('The Draw.FillOval procedure is used to draw a filled oval whose center is at (x, y). The horizontal and vertical distances from the center to the oval are given by xRadius and yRadius', 'Draw.FillOval (x, y, xRadius, yRadius, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Oval fill colour']);
                case 'Arc': return hoverCompletions_1.hover('The Draw.Arc procedure is used to draw an arc whose center is at (x, y). This is just like drawoval, except that you must also give two angles, initialAngle and finalAngle, which determine where to start and stop drawing', 'Draw.Arc (x, y, xRadius, yRadius : int, initialAngle, finalAngle, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'initialAngle', 'finalAngle', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Start angle of the arc. 0 degrees is East, 90 is North', 'End angle of the arc. 0 degrees is East, 90 is North', 'Arc colour']);
                case 'FillArc': return hoverCompletions_1.hover('The Draw.FillArc procedure is used to draw a filled arc whose center is at (x, y). It then fills in the pie-shaped wedge using the specified Color', 'Draw.FillArc (x, y, xRadius, yRadius : int, initialAngle, finalAngle, Color : int)', '(Procedure)', ['x', 'y', 'xRadius', 'yRadius', 'initialAngle', 'finalAngle', 'Colour'], ['Center X position', 'Center Y position', 'Radius along x axis', 'Radius along y axis', 'Start angle of the arc. 0 degrees is East, 90 is North', 'End angle of the arc. 0 degrees is East, 90 is North', 'Arc fill colour']);
                case 'Polygon': return hoverCompletions_1.hover('The Draw.Polygon procedure is used to draw a polygon with n points. A line is drawn in Color from the point (x(1), y(1)) to (x(2), y(2)) to (x(3), y(3)) and so on', 'Draw.Polygon (x, y : array 1 .. * of int, n : int, Color : int)', '(Procedure)', ['x', 'y', 'n', 'Colour'], ['Array of x positions of points on polygon', 'Array of y positions of points on polygon', 'Number of sides on the polygon', 'Polygon colour']);
                case 'FillPolygon': return hoverCompletions_1.hover('The Draw.FillPolygon procedure is used to draw a filled polygon with n points. The polygon is described by the points (x(1), y(1)) to (x(2), y(2)) to (x(3), y(3)) and so on to (x(n), y (n))', 'Draw.FillPolygon (x, y : array 1 .. * of int, n : int, Color : int)', '(Procedure)', ['x', 'y', 'n', 'Colour'], ['Array of x positions of points on polygon', 'Array of y positions of points on polygon', 'Number of sides on the polygon', 'Polygon fill colour']);
                case 'MapleLeaf': return hoverCompletions_1.hover('The Draw.MapleLeaf procedure is used to draw a maple leaf on the screen bounded by a rectangle described by the bottom left and top right corners of (x1, y1) to (x2, y2) using the specified Color', 'Draw.MapleLeaf (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Maple leaf colour']);
                case 'FillMapleLeaf': return hoverCompletions_1.hover('The Draw.FillMapleLeaf procedure is used to draw a filled maple leaf on the screen bounded by a rectangle with bottom left and top right corners of (x1, y1) to (x2, y2) and filled using the specified Color', 'Draw.FillMapleLeaf (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Maple leaf fill colour']);
                case 'Star': return hoverCompletions_1.hover('The Draw.Star procedure is used to draw a star on the screen bounded by a rectangle described by the bottom left and top right corners of (x1, y1) to (x2, y2) using the specified Color', 'Draw.Star (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Star colour']);
                case 'FillStar': return hoverCompletions_1.hover('The Draw.FillStar procedure is used to draw a filled five pointed star on the screen bounded by a rectangle with bottom left and top right corners of (x1, y1) to (x2, y2) and filled using the specified Color', 'Draw.FillStar (x1, y1, x2, y2, Color : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2', 'Colour'], ['Bottom left corner X position', 'Bottom left corner Y position', 'Top right corner X position', 'Top right corner Y position', 'Star fill colour']);
                case 'Fill': return hoverCompletions_1.hover('The Draw.Fill procedure is used to color in a figure that is on the screen. Starting at (x, y), the figure is filled with fillColor to a surrounding border whose color is borderColor', 'Draw.Fill (x, y : int, fillColor, borderColor : int)', '(Procedure)', ['x', 'y', 'fillColour', 'borderColour'], ['X position of fill', 'Y position of fill', 'Colour to fill in', 'Colour of border']);
                case 'Text': return hoverCompletions_1.hover('Draw.Text is used to actually draw text in a specified font. The textStr parameter contains the string to be drawn. The x and y parameters are the location of the lower left hand corner of the text to be displayed', 'Draw.Text (txtStr : string, x, y, fontID, Color : int)', '(Procedure)', ['textStr', 'x', 'y', 'fontID', 'Colour'], ['Text to display', 'Lower left corner X position', 'Lower left corner Y position', 'Text font', 'Text colour']);
            }
        }
        else if (line.search(/(?<=Error.)(LastMsg|LastStr|Last|Msg|Str|TripMsg|Trip|Halt)/) >= 0) {
            switch (sWord) {
                case 'Last': return hoverCompletions_1.hover('Error.Last is a function that returns the error code set by the last called predefined subprogram. If there is no error, then it returns eNoError (which is 0). If there is an error, you can use Error.LastMsg to obtain a textual form of the error or Error.LastStr to obtain a string version of the error constant', 'Error.Last : int', '(Constant)', [], [], 'Last error');
                case 'LastMsg': return hoverCompletions_1.hover('Error.LastMsg is a function that returns the error message set by the last called predefined subprogram. If there is no error, then it returns the empty string. If there is an error, you can use Error.Last to obtain the error code', 'Error.LastMsg : string', '(Constant)', [], [], 'Last error message');
                case 'LastStr': return hoverCompletions_1.hover('Error.LastStr is a function that returns the string version of the error code set by the last called predefined subprogram', 'Error.LastStr : string', '(Constant)', [], [], 'Last error message string');
                case 'Msg': return hoverCompletions_1.hover('Error.Msg is a function that returns the error message related to a specified error code. If the error code is eNoError, or if there is no such error code, it returns the empty string. If there is such an error, it returns the textual message associated with that error', 'Error.Msg (errorCode : int): string', '(Function)', ['errorCode'], ['Error code'], 'Error message');
                case 'Str': return hoverCompletions_1.hover('Error.Str is a function that returns the error message related to a specified error code. If the error code is eNoError or if there is no such error code, it returns the empty string. If there is such an error, it returns the textual message associated with that error', ' 	Error.Str (errorCode : int): string', '(Function)', ['errorCode'], ['Error code'], 'Error string');
                case 'Trip': return hoverCompletions_1.hover('Error.Trip is a procedure that sets the error number that is returned by Error.Last and Error.LastMsg. It does not halt the program', 'Error.Trip (errorCode : int)', '(Procedure)', ['errorCode'], ['Error code']);
                case 'TripMsg': return hoverCompletions_1.hover('Error.TripMsg is a procedure that sets the error number and error message that is returned by Error.Last and Error.LastMsg. It does not halt the program', 'Error.TripMsg (errorCode : int, errorMessage : string)', '(Procedure)', ['errorCode', 'errorMessage'], ['Error Code', 'Error code message']);
                case 'Halt': return hoverCompletions_1.hover('Error.Halt is a procedure that immediately halts execution of the program and shows the specified error message on the line in the program that calls Error.Halt', 'Error.Halt (errorMessage : string)', '(Procedure)', ['errorMessage'], ['Error code message']);
            }
        }
        else if (line.search(/(?<=File.)(Exists|FullPath|Parent|Status|Copy|Rename|Delete|DiskFree)/) >= 0) {
            switch (sWord) {
                case 'Exists': return hoverCompletions_1.hover('File.Exists returns true if a file by the name of pathName exists. It will return false if pathName is a directory', 'File.Exists (pathName : string) : boolean', '(Function)', ['pathName'], ['Path to file'], 'If file at pathName exists');
                case 'FullPath': return hoverCompletions_1.hover('File.FullPath returns a string representing the full absolute path name in Turing format (forward slashes) of the path that is passed to the function. The path name passed in does not have to describe an existing file or directory', 'File.FullPath (pathName) : string) : string', '(Function)', ['pathName'], ['Path to file'], 'Absolute path to file');
                case 'Parent': return hoverCompletions_1.hover('File.Parent returns a string representing the parent directory in Turing format (forward slashes) of the path passed as a parameter. The path name passed in does not have to describe an existing file or directory', 'File.Parent (pathName : string) : string', '(Function)', ['pathName'], ['Path to file'], 'Path to parent directory');
                case 'Status': return hoverCompletions_1.hover('File.Status is used to get assorted information about a file or directory. When the function is called with a specified pathName, it returns the information about the file in the other parameters', 'File.Status (pathName : string, var size, attribute, fileTime : int)', '(Procedure)', ['pathName', 'size', 'attribute', 'fileTime'], ['Path to file', 'Variable parameter is set to size of file', 'Variable parameter is set to attributes of file', 'Time since last modification']);
                case 'Copy': return hoverCompletions_1.hover('File.Copy copies a file named by the srcPathName parameter to the file named by the destPathName parameter. The copy can be between different disks or file systems', 'File.Copy (srcPathName, destPathName : string)', '(Procedure)', ['srcPathName', 'destPathName'], ['Path to source file', 'Path to destination file']);
                case 'Rename': return hoverCompletions_1.hover('File.Copy renames a file or directory named by the srcPathName parameter to the destName parameter. The destName parameter must be a name only', 'File.Rename (srcPathName, destName : string)', '(Procedure)', ['srcPathName', 'destPathName'], ['Path to source file', 'Path to renamed file']);
                case 'Delete': return hoverCompletions_1.hover('File.Delete is used to delete the file specified by the parameter filePathName. This is the equivalent of doing a del in DOS or rm in UNIX', 'File.Delete (filePathName : string)', '(Procedure)', ['filePathName'], ['Path to file to delete']);
                case 'DiskFree': return hoverCompletions_1.hover('File.DiskFree gets the number of bytes for the disk upon which pathName resides. The pathName parameter can specify either a file or a directory. If it is the empty string, then File.DiskFree returns the number of bytes of free disk space on the disk upon which the execution directory resides', 'File.DiskFree (pathName : string) : int', '(Function)', ['pathName'], ['Path to file'], 'Bytes of free space (2gb max)');
            }
        }
        else if (line.search(/(?<=Limits.)(DefaultFW|DefaultEW|Radix|NumDigits|MinExp|MaxExp|Rreb)/) >= 0) {
            switch (sWord) {
                case 'DefaultFW': return hoverCompletions_1.hover('Default fraction width used in printing using the "put" statement', 'Limits.DefaultFW', '(Constant)');
                case 'DefaultEW': return hoverCompletions_1.hover('Default exponent width used in printing using the "put" statement', 'Limits.DefaultEW', '(Constant)');
                case 'Radix': return hoverCompletions_1.hover('The "radix (usually 2)', 'Limits.Radix', '(Constant)');
                case 'NumDigits': return hoverCompletions_1.hover('The number of radix digits in f', 'Limits.NumDigits', '(Constant)');
                case 'MinExp': return hoverCompletions_1.hover('"minexp" (the smallest exponent allowed)', 'Limits.MinExp', '(Constant)');
                case 'MaxExp': return hoverCompletions_1.hover('"maxexp" (the largest exponent allowed)', 'Limits.MaxExp', '(Constant)');
                case 'Rreb': return hoverCompletions_1.hover('The relative round-off error bound', 'Limits.Rreb', '(Constant)');
            }
        }
        else if (line.search(/(?<=Input.)(Pause|KeyDown|Flush)/) >= 0) {
            switch (sWord) {
                case 'Pause': return hoverCompletions_1.hover('The Input.Pause procedure simply waits for a key to be pressed and then returns. It echoes the key pressed if echo mode is set. (See View.Set for setting echo mode)', 'Input.Pause', '(Procedure)');
                case 'KeyDown': return hoverCompletions_1.hover('The Input.Keydown procedure allows a program to read which keys are currently being pressed. This procedure is different from getch in that it allows a program to detect when a user presses and releases a button. As such, it is not to be used in conjunction with getch', 'Input.KeyDown (var chars : array char of boolean)', '(Procedure)', ['chars'], ['Variable chars of type array char of boolean']);
                case 'Flush': return hoverCompletions_1.hover('The Input.Flush procedure empties the keyboard buffer. It is often used to avoid accidentally reading multiple keystrokes because the user pressed a key for too long, causing autorepeat', 'Input.Flush', '(Procedure)');
            }
        }
        else if (line.search(/(?<=Math.)(DistancePointLine|Distance|PI|E)/) >= 0) {
            switch (sWord) {
                case 'PI': return hoverCompletions_1.hover('The constant Pi π = ~3.1415', 'Math.PI', '(Constant)');
                case 'E': return hoverCompletions_1.hover('Eulers number e = ~2.7183', 'Math.E', '(Constant)');
                case 'Distance': return hoverCompletions_1.hover('Math.Distance is used to calculate the distance between two points. (x1, y1) is the location of the first point, and (x2, y2) is the location of the second point', 'Math.Distance (x1, y1, x2, y2 : real) : real', '(Function)', ['x1', 'y1', 'x2', 'y2'], ['Point 1 X position', 'Point 1 Y position', 'Point 2 X position', 'Point 2 Y position'], 'Distance between input points');
                case 'DistancePointLine': return hoverCompletions_1.hover('Math.DistancePointLine is used to calculate the distance between a point and a line segment. It is often used in games to determine if a collision has occurred. (xp, yp) is the location between the point. (x1, y1) and (x2, y2) are the end points of the line segment', 'Math.DistancePointLine (xp, yp, x1, y1, x2, y2 : real) : real', '(Function)', ['xp', 'yp', 'x1', 'y1', 'x2', 'y2'], ['Point X position', 'Point Y position', 'Line point 1 X position', 'Line point 1 Y position', 'Line point 2 X position', 'Line point 2 Y position'], 'Min distance between input point and input line');
            }
        }
        else if (line.search(/(?<=Mouse.)(Where|ButtonMoved|ButtonWait|ButtonChoose)/) >= 0) {
            switch (sWord) {
                case 'Where': return hoverCompletions_1.hover('The Mouse.Where procedure is used to get current information about the status of the mouse. The parameters x and y are set to the current location of the mouse cursor. If the program is running on a system using windows, the cursor may be outside the window. This means that x and y may be set to values outside of the bounds of 0 to maxx and 0 to maxy', 'Mouse.Where (var x, y, button : int)', '(Procedure)', ['x', 'y', 'button'], ['Input variable set to mouse X position', 'Input variable set to mouse Y position', 'Input variable set to mouse button']);
                case 'ButtonMoved': return hoverCompletions_1.hover('The Mouse.ButtonMoved function indicates whether there is a mouse event of the appropriate type on the mouse queue. Events are either "up", "down", "updown" or "downup" events (although the "downup" and "updown" are the same event)', 'Mouse.ButtonMoved (motion : string) : boolean', '(Function)', ['motion'], ['Mouse event to ask for'], 'If mouse event occurred');
                case 'ButtonWait': return hoverCompletions_1.hover('The Mouse.ButtonWait procedure gets information about a mouse event and removes it from the queue', 'Mouse.ButtonWait (motion : string, var x, y, buttonNumber, buttonUpDown : int)', '(Procedure)', ['motion', 'x', 'y', 'buttonNumber', 'buttonUpDown'], ['Mouse event', 'Input variable set to mouse X position', 'Input variable set to mouse Y position', 'Input variable set to mouse number', 'Input variable set to button event']);
                case 'ButtonChoose': return hoverCompletions_1.hover('The Mouse.ButtonChoose procedure is used to change the mode of the mouse. In Turing, the mouse can either be in "single-button mode" or in "multi-button mode". In "single-button mode" the mouse is treated as a one button mouse. A button is considered pressed when any button is pressed and released only when all buttons have been released', 'Mouse.ButtonChoose (choice : string)', '(Procedure)', ['choice'], ['Mode to set mouse to']);
            }
        }
        else if (line.search(/(?<=Music.)(PlayFileStop|PlayFileLoop|PlayFileReturn|PlayFile|Play|SoundOff|Sound)/) >= 0) {
            switch (sWord) {
                case 'PlayFileStop': return hoverCompletions_1.hover('The Music.PlayFileStop procedure is used to to stop all music files currently playing. This includes processes that are executing the Music.PlayFile procedure (they exit immediately and start executing the next statement in the process), and the Music.PlayFileReturn and Music.PlayFileLoop statements, which simply stop playing the music', 'Music.PlayFileStop', '(Procedure)');
                case 'PlayFileLoop': return hoverCompletions_1.hover('The Music.PlayFileLoop procedure is used to play a file of music continuously, looping until the program is halted or the Music.PlayFileStop command is given. The file must be in one of the acceptable formats and the machine, must have the appropriate hardware', 'Music.PlayFileLoop ( fileName : string )', '(Procedure)', ['fileName'], ['Name of music file to play']);
                case 'PlayFileReturn': return hoverCompletions_1.hover('The Music.PlayFileReturn procedure is used to play a file of music. The file must be in one of the acceptable formats and the machine, must have the appropriate hardware', 'Music.PlayFileReturn ( fileName : string )', '(Procedure)', ['fileName'], ['Name of music file to play']);
                case 'PlayFile': return hoverCompletions_1.hover('The Music.PlayFile procedure is used to play a file of music. The file must be in one of the acceptable formats and the machine, must have the appropriate hardware', 'Music.PlayFile ( fileName : string )', '(Procedure)', ['fileName'], ['Name of music file to play']);
                case 'Play': return hoverCompletions_1.hover('The Music.Play procedure is used to sound musical notes on the computer', 'Music.Play ( music : string )', '(Procedure)', ['music'], ['String of notes to play']);
                case 'SoundOff': return hoverCompletions_1.hover('The Music.SoundOff procedure stops any sound or music that is currently playing or is waiting to play', 'Music.SoundOff', '(Procedure)');
                case 'Sound': return hoverCompletions_1.hover('The Music.Sound statement is used to cause the computer to sound a note of a given frequency for a given time. The frequency is in cycles per second (Hertz). The time duration is in milliseconds. For example, middle A on a piano is 440 Hertz, so Music.Sound(440, 1000) plays middle A for one second', 'Music.Sound ( frequency, duration : int )', '(Procedure)', ['frequency', 'duration'], ['Frequency of sound to play', 'Duration to play frequency']);
            }
        }
        else if (line.search(/(?<=Net.)(WaitForConnection|OpenConnection|OpenURLConnection|CloseConnection|BytesAvailable|CharAvailable|LineAvailable|TokenAvailable|HostAddressFromName|HostNameFromAddress|LocalAddress|LocalName)/) >= 0) {
            switch (sWord) {
                case 'WaitForConnection': return hoverCompletions_1.hover('Listens for a connection at the port specified by the port parameter. When another program connects to the port, then the function returns. The address of the connecting machine is specified in the netAddr parameter and the Net.WaitForConnection returns a network stream descriptor which can be used with the put, get, read, and write statements and eof function to send and receive data to the connecting program. It is also the parameter used for the Net.CloseConnection, Net.BytesAvailable, Net.CharAvailable, Net.LineAvailable, and Net.TokenAvailable functions', 'Net.WaitForConnection (port : int, var netAddr : string) : int', '(Function)', ['port', 'netAddr'], ['Port to listen on', 'Variable set to the address of connecting device'], 'Stream id to listen to data');
                case 'OpenConnection': return hoverCompletions_1.hover('Attempts to open a connection to port specified by the port parameter on the machine specified by netAddr parameter. There must be a program listening to that port for the connection to be made. In OOT, this is done using the Net.WaitForConnection function', 'Net.OpenConnection (netAddr : string, port : int) : int', '(Function)', ['netAddr', 'port'], ['Address to computer to send information to', 'Port to send information to'], 'Stream id to send data to');
                case 'OpenURLConnection': return hoverCompletions_1.hover('Attempts to open a http connection to pthe URL (Universal Resource Locator) specified by the urlAddr', 'Net.OpenURLConnection (urlAddr : string) : int', '(Function)', ['urlAddr'], ['Url to open a connection to'], 'Stream id to send data to');
                case 'CloseConnection': return hoverCompletions_1.hover('Closes a network connection made with Net.OpenConnection or Net.WaitForConnection. After the connection is closed, the net stream cannot be used for any purpose on either side of the connection', 'Net.CloseConnection (netStream : int)', '(Procedure)', ['netStream'], ['Id of net stream returned when connection was opened']);
                case 'BytesAvailable': return hoverCompletions_1.hover('Returns the number of bytes available for reading from the net stream specified by the netStream parameter', 'Net.BytesAvailable (netStream : int) : int', '(Function)', ['netStream'], ['Id of net stream returned when connection was opened'], 'Number of bytes of stream left to read');
                case 'CharAvailable': return hoverCompletions_1.hover('Returns true if a character is waiting to be read from the net stream specified by the netStream parameter. If Net.CharAvailable returns true, then a single character can be read from the stream without blocking', 'Net.CharAvailable (netStream : int) : boolean', '(Function)', ['netStream'], ['Id of net stream returned when connection was opened'], 'If a char is able to be read from stream');
                case 'LineAvailable': return hoverCompletions_1.hover('Returns true if a line of input is waiting to be read from the net stream specified by the netStream parameter. If Net.LineAvailable returns true, then a line of input can be read from the stream without blocking', 'Net.LineAvailable (netStream : int) : boolean', '(Function)', ['netStream'], ['Id of net stream returned when connection was opened'], 'If a line is able to be read from stream');
                case 'TokenAvailable': return hoverCompletions_1.hover('Returns true if a line of input is waiting to be read from the net stream specified by the netStream parameter. If Net.TokenAvailable returns true, then a single token (character surrounded by whitespace) can be read from the stream without blocking', 'Net.TokenAvailable (netStream : int) : boolean', '(Function)', ['netStream'], ['Id of net stream returned when connection was opened'], 'If a token is able to be read from stream');
                case 'HostAddressFromName': return hoverCompletions_1.hover('Returns the numeric TCP/IP address of the machine whose hostname is specified by the hostName parameter', 'Net.HostAddressFromName (hostName : string) : string', '(Function)', ['hostName'], ['Hostname of a machine'], 'Tcp/Ip address of hostname');
                case 'HostNameFromAddress': return hoverCompletions_1.hover('Returns the TCP/IP hostname of the machine whose numeric address is specified by the hostAddr parameter', 'Net.HostNameFromAddress (hostAddr : string) : string', '(Function)', ['hostAddr'], ['Tcp/Ip address of a machine'], 'Hostname of Tcp/Ip address');
                case 'LocalAddress': return hoverCompletions_1.hover('Returns the TCP/IP numeric address of the machine the program is running on. The numeric address is of the form xxx.yyy.zzz.www where each segment is a number from 0 to 255', 'Net.LocalAddress : string', '(Constant)', [], [], 'Local ip address of machine');
                case 'LocalName': return hoverCompletions_1.hover('Returns the TCP/IP hostname of the machine the program is running on', 'Net.LocalName : string', '(Constant)', [], [], 'Hostname of machine');
            }
        }
        else if (line.search(/(?<=PC.)(ParallelGet|ParallelPut)/) >= 0) {
            switch (sWord) {
                case 'ParallelGet': return hoverCompletions_1.hover('The PC.ParallelGet procedure is used on a PC to read the value of certain pins on the parallel port. This port corresponds to the MS-DOS device "LPT1". This procedure can be used to control robots and peripherals', 'PC.ParallelGet (port : int) : nat1', '(Function)', ['port'], ['Parallel port to receive data from'], 'Decimal of byte representing which pins are high. If high is = 1 and low = 0, Then number `88` represents `1011000` means Pin 11 is high, Pin 10 is low, Pin 12 is gigh, Pin 13 is high, Pin 15 is low');
                case 'ParallelPut': return hoverCompletions_1.hover('The PC.ParallelPut procedure is used on a PC to set the values on the data pins on the parallel port. This port corresponds to the MS-DOS device "LPT1". This procedure can be used to control robots and peripherals', 'PC.ParallelPut (port : int, value : int)', '(Function)', ['port', 'value'], ['Parallel port to send data do', 'Byte where each pin represents each place in the binary representation of the byte']);
            }
        }
        else if (line.search(/(?<=Rand.)(Real|Int|Reset|Set|Next|Seed)/) >= 0) {
            switch (sWord) {
                case 'Real': return hoverCompletions_1.hover('The Rand.Real function returns a pseudo-random number in the range zero to one. For example, if x is a real number, after x := Rand.Real, x would have a value such as 0.729548 or 0.352879', 'Rand.Real : real', '(Function)', [], [], 'A random number of type `real`');
                case 'Int': return hoverCompletions_1.hover('The Rand.Int statement is used to create a pseudo-random integer in the range low to high, inclusive. For example, if i is an integer, after randint(i,1, 10), i would have a value such as 7 or 2 or 10', 'Rand.Int (low, high : int) : int', '(Function)', ['low', 'high'], ['Lower bound of possible numbers', 'Upper bound of possible numbers'], 'A random number of type `int` between `low` and `high`');
                case 'Reset': return hoverCompletions_1.hover('This is a procedure with no parameters that resets the sequences of pseudo-random numbers produced by Rand.Real and Rand.Int. This allows identical executions of the same program to produce identical results', 'Rand.Reset', '(Procedure)');
                case 'Set': return hoverCompletions_1.hover('This procedure sets the seed for sequences of pseudo-random numbers produced by Rand.Real and Rand.Int. This allows identical executions of the same program to produce identical results', 'Rand.Set (seed : nat4)', '(Procedure)', ['seed'], ['Seed to set random to']);
                case 'Next': return hoverCompletions_1.hover('The Rand.Next procedure is used when you need several sequences of pseudo-random numbers, and you need to be able to exactly repeat these sequences for a number of simulations. The Rand.Next procedure is the same as rand, except seq specifies one of ten independent and repeatable sequences of pseudo-random real numbers', 'Rand.Next (seq : 1 .. 10) : real', '(Function)', ['seq'], ['Input sequence'], 'Output number of type real');
                case 'Seed': return hoverCompletions_1.hover('The Rand.Seed procedure restarts one of the sequences generated by Rand.Next. Each restart with the same seed causes Rand.Next to produce the same sequence for the given sequence', 'Rand.Seed (seed : nat4, seq : 1 .. 10)', '(Procedure)', ['seed', 'seq'], ['Seed to start sequence at', 'Input sequence']);
            }
        }
        else if (line.search(/(?<=RGB.)(GetColour|SetColour|AddColour)/) >= 0) {
            switch (sWord) {
                case 'GetColour': return hoverCompletions_1.hover('The RGB.GetColour procedure returns the red, green and blue components to the color associated with the colorNumber parameter. The red, green and blue values are normalized to be between 0 and 1. Thus color white returns 1.0 for the redComp, greenComp and blueComp values and colour black returns 0.0 for all three', 'RGB.GetColour(colourNumber : int, var redComp, greenComp, blueComp : real)', '(Procedure)', ['colourNumber', 'redComp', 'greenComp', 'blueComp'], ['Colour id to get', 'Variable to set red value to', 'Variable to set green value to', 'Variable to set blue value to']);
                case 'SetColour': return hoverCompletions_1.hover('The RGB.SetColour function sets the red, green and blue components of the color associated with the colourNumber parameter. The red, green and blue values must normalized to be between 0 and 1', 'RGB.SetColour(colourNumber : int, redComp, greenComp, blueComp : real)', '(Procedure)', ['colourNumber', 'redComp', 'greenComp', 'blueComp'], ['Colour id to set', 'Red value (0-1)', 'Green value (0-1)', 'Blue value (0-1)']);
                case 'AddColour': return hoverCompletions_1.hover('The RGB.AddColour function attempts to create a new colour with the red, green and blue components specified. If successful, the function returns a new color number (usually one greater than maxcolor) and maxcolor is updated by adding 1 to it. If it is unsuccessful, the function returns 1 and Error.Last and Error.LastMsg can be used to determine the cause of the problem', 'RGB.AddColour(redComp, blueComp, greenComp)', '(Function)', ['redComp', 'blueComp', 'greenComp'], ['Colour id to set', 'Red value (0-1)', 'Green value (0-1)', 'Blue value (0-1)'], 'Id of newly created colour');
            }
        }
        else if (line.search(/(?<=Stream.)(FlushAll|Flush)/) >= 0) {
            switch (sWord) {
                case 'Flush': return hoverCompletions_1.hover('The Stream.Flush procedure is used to flush any buffered output associated with the streamNumber parameter', 'Stream.Flush ( streamNumber : int )', '(Procedure)', ['streamNumber'], ['Id of stream to flush']);
                case 'FlushAll': return hoverCompletions_1.hover('The Stream.FlushAll procedure is used to flush any buffered output in any open file', 'Stream.FlushAll', '(Procedure)');
            }
        }
        else if (line.search(/(?<=Str.)(Lower|Upper|Trim)/) >= 0) {
            switch (sWord) {
                case 'Lower': return hoverCompletions_1.hover('The Str.Lower function takes the string s and returns a string in which all the upper case letters are converted to lower case. For example, Str.Lower ("ABC123def") returns "abc123def"', 'Str.Lower (s : string) : string', '(Function)', ['s'], ['Input string to put into lowercase'], 'Lowercase output string');
                case 'Upper': return hoverCompletions_1.hover('The Str.Upper function takes the string s and returns a string in which all the lower case letters are converted to upper case. For example, Str.Upper ("ABC123def") returns "ABC123DEF"', 'Str.Upper (s : string) : string', '(Function)', ['s'], ['Input string to put into uppercase'], 'Uppercase output string');
                case 'Trim': return hoverCompletions_1.hover('The Str.Trim function takes the string str and returns a string in all the leading and trailing spaces (the spaces at the beginning and the end) are deleted. For example, Str.Trim (" This is a test ") returns "This is a test". If str only has spaces in it, then Str.Trim will return an empty string', 'Str.Trim (str : string) : string', '(Function)', ['str'], ['Input string to trim'], 'Output trimmed string');
            }
        }
        else if (line.search(/(?<=Sys.)(GetComputerName|GetEnv|GetPid|GetUserName|Exec|Nargs|FetchArg)/) >= 0) {
            switch (sWord) {
                case 'GetComputerName': return hoverCompletions_1.hover('The Sys.GetComputerName function is used to determine the name of the computer. On the PC, this is the NetBIOS name. It returns “No Name” if a name could not be determined', ' 	Sys.GetComputerName : string', '(Function)', [], [], 'Computer name');
                case 'GetEnv': return hoverCompletions_1.hover('The Sys.GetEnv function is used to access the environment string whose name is symbol. These strings are determined by the shell (command processor) or the program that caused your program to run. See also the Sys.Nargs and Sys.FetchArg functions', 'Sys.GetEnv ( symbol : string ) : string', '(Function)', ['symbol'], ['Setting to get'], 'Resulting setting');
                case 'GetPid': return hoverCompletions_1.hover('The Sys.GetPid function is used to determine the I.D. (number) that identifies the current operating system task (process). Beware that there are processes, activated by the fork statement, that are independent of the operating systems tasks', 'Sys.GetPid : int', '(Function)', [], [], 'Pid of program');
                case 'GetUserName': return hoverCompletions_1.hover('The Sys.GetUserName function is used to determine the name of the current user. It returns “Unknown” if a name could not be determined', 'Sys.GetUserName : string', '(Function)', [], [], 'Username of computer');
                case 'Exec': return hoverCompletions_1.hover('The Sys.Exec function is used to execute an application or more often, open a data file with its associated application. Sys.Exec can be used to launch such programs as the Internet Browser by specifying a URL. Sys.Exec launches the application associated with file\'s suffix. (In essence, it performs the same operation as if a user double clicked on the file.)', 'Sys.Exec ( command : string ) : boolean', '(Function)', ['command'], ['System command to be run'], 'If the command executed properly');
                case 'Nargs': return hoverCompletions_1.hover('The Sys.Nargs function is used to determine the number of arguments that have been passed to a program from the command line. For example, if the program is run from the Turing environment using', 'Sys.Nargs : int', '(Constant)', [], [], 'Number of arguments passed in from the command line');
                case 'FetchArg': return hoverCompletions_1.hover('The Sys.FetchArg function is used to access the i-th argument that has been passed to a program from the command line', 'System.FetchArg ( i : int ) : string', '(Function)', ['i'], ['Which argument to access'], 'Output string of argument');
            }
        }
        else if (line.search(/(?<=Text.)(Cls|ColourBack|Colour|LocateXY|Locate|WhatRow|WhatColourBack|WhatColour|WhatCol)/) >= 0) {
            switch (sWord) {
                case 'Cls': return hoverCompletions_1.hover('The Text.Cls (clear screen) procedure is used to blank the screen to the text background color. The cursor is set to the top left (to row 1, column 1)', 'Text.Cls');
                case 'ColourBack': return hoverCompletions_1.hover('The Text.ColourBack procedure is used to change the current text background colour', 'Text.ColorBack ( Colour : int )', '(Procedure)', ['Colour'], ['Colour to set the background colour to']);
                case 'Colour': return hoverCompletions_1.hover('The Text.Colour procedure is used to change the currently-active colour. This is the colour of characters that are to be put on the screen', 'Text.Colour ( Colour : int )', '(Procedure)', ['Colour'], ['Colour to set the text to']);
                case 'LocateXY': return hoverCompletions_1.hover('The Text.LocateXY procedure is used to move the cursor so that the next output from put will be at approximately (x, y). The exact location may be somewhat to the left of x and below y to force alignment to a character boundary', 'Text.LocateXY ( x , y : int )', '(Procedure)', ['x', 'y'], ['X position to set curser to', 'Y position to set curser to']);
                case 'Locate': return hoverCompletions_1.hover('The Text.Locate procedure is used to move the cursor so that the next output from put will be at the given row and column. Row 1 is the top of the screen and column 1 is the left side of the screen', 'Text.Locate ( row, column : int )', '(Procedure)', ['row', 'column'], ['Row to set curser to', 'Column to set curser to']);
                case 'WhatRow': return hoverCompletions_1.hover('The Text.WhatRow function is used to determine the cursor position\'s row', 'Text.WhatRow : int', '(Constant)', [], [], 'Current row of curser');
                case 'WhatColourBack': return hoverCompletions_1.hover('The Text.WhatColourBack function is used to determine the current text background colour', ' 	Text.WhatColourBack : int', '(Constant)', [], [], 'Current background colour at the curser');
                case 'WhatColour': return hoverCompletions_1.hover('The Text.WhatColour function is used to determine the current text (foreground) colour, ie., the color used for characters that are output using put', 'Text.WhatColour : int', '(Constant)', [], [], 'Current colour at the curser');
                case 'WhatCol': return hoverCompletions_1.hover('The Text.WhatCol function is used to determine the cursor position\'s column', 'Text.WhatCol : int', '(Constant)', [], [], 'Current column of curser');
            }
        }
        else if (line.search(/(?<=Time.)(SecDate|DateSec|SecParts|PartsSec|SecStr|DelaySinceLast|Delay|Sec|Date|ElapsedCPU|Elapsed)/) >= 0) {
            switch (sWord) {
                case 'SecDate': return hoverCompletions_1.hover('The Time.SecDate function is used to convert the number of seconds since 00:00:00 GMT Jan 1, 1970 into a date and time string', 'Time.SecDate (timeInSecs : int) : string', '(Function)', ['timeInSecs'], ['Input time in seconds'], 'Output date as type string');
                case 'DateSec': return hoverCompletions_1.hover('The Time.DateSec function is used to convert a date and time string into a number, specifically, the number of seconds since 00:00:00 GMT Jan 1, 1970', 'Time.DateSec (dateString : string) : int', '(Function)', ['dateString'], ['Input date as string "dd mmm yy"'], 'Output time as seconds since Jan 1, 1970');
                case 'SecParts': return hoverCompletions_1.hover('The Time.SecParts function is used to convert a single number form of the time (the number of seconds since 00:00:00 GMT Jan 1, 1970) into a date with numeric component parts', ' 	Time.SecParts (sec : int, var year, month, day, dayOfWeek, hour, minute, second : int)', '(Procedure)', ['sec', 'year', 'month', 'day', 'dayOfWeek', 'hour', 'minute', 'second'], ['Seconds since Jan 1, 1970', 'Variable output year', 'Variable output month', 'Variable output day', 'Variable output dayOfWeek', 'Variable otuput hour', 'Variable output minute', 'Variable output second']);
                case 'PartsSec': return hoverCompletions_1.hover('The Time.PartsSec function is used to convert the numeric parts of a date (specifically the year, month, day, hour, minute and second) into the number of seconds since 00:00:00 GMT Jan 1, 1970 and the date specified by the parts', 'Time.PartsSec (year, month, day, hour, minute, second : int) : int', '(Function)', ['year', 'month', 'day', 'hour', 'minute', 'second'], ['Input year', 'Input month', 'Input day', 'Input hour', 'Input minute', 'Input second'], 'Output time as seconds since Jan 1, 1970');
                case 'SecStr': return hoverCompletions_1.hover('The Time.SecStr function is used to convert the number of seconds since 00:00:00 GMT Jan 1, 1970 into a date and time string', 'Time.SecStr (timeInSecs : int, formatString : string) : string', '(Function)', ['timeInSecs', 'formatString'], ['Seconds since Jan 1, 1970', 'Time [Format string](http://compsci.ca/holtsoft/doc/time_secstr.html)'], 'Formatted date string');
                case 'Delay': return hoverCompletions_1.hover('The Time.Delay procedure is used to cause the program to pause for a given time. The time duration is in milliseconds', 'Time.Delay ( duration : int )', '(Procedure)', ['duration'], ['Time to wait (ms)']);
                case 'DelaySinceLast': return hoverCompletions_1.hover('The Time.DelaySinceLast procedure is used to cause the program to pause for a given time since the last call to Time.DelaySinceLast. The time duration is in milliseconds', 'Time.DelaySinceLast ( duration : int )', '(Procedure)', ['duration'], ['Wait until `Duration` has passed since the start of execution']);
                case 'Sec': return hoverCompletions_1.hover('The Time.Sec function returns the current date and time as a number. The returned integer is the time in seconds since 00:00:00 GMT (Greenwich Mean Time) January 1, 1970', 'Time.Sec : int', '(Constant)', [], [], 'Seconds since Jan 1, 1970');
                case 'Date': return hoverCompletions_1.hover('The Time.Date function returns the current date and time as a string. The returned string in the format "dd mmm yy hh:mm:ss", where mmm is the first 3 characters of the month, e.g., "Apr". For example, if the date is Christmas 1989 at 9:02:37 in the morning, Time.Date will return "25 Dec 89 09:02:37". Twenty-four hour time is used, so eleven thirty at night the same day would return "25 Dec 89 23:30:00"', 'Time.Date : string', '(Constant)', [], [], 'Get date as string');
                case 'Elapsed': return hoverCompletions_1.hover('The Time.Elapsed function returns the amount of time since a program (process) started running. The number of milliseconds since the program started running is returned', 'Time.Elapsed : int', '(Constant)', [], [], 'Time since program start (ms)');
                case 'ElapsedCPU': return hoverCompletions_1.hover('The Time.ElapsedCPU function is used on a multitasking system such as UNIX to determine the amount of time that has been used by this program (process). The number of central processor milliseconds assigned to this program is returned. This is of little use on a personal computer, where Time.ElapsedCPU returns the same value as Time.Elapsed', 'Time.ElapsedCPU : int', '(Constant)', [], [], 'Time of CPU usage (ms)');
            }
        }
        else if (line.search(/(?<=View.)(Set|ClipSet|ClipAddOval|ClipAdd|WhatDotColour|UpdateArea|Update|maxx|maxy|maxcolour)/) >= 0) {
            switch (sWord) {
                case 'maxx': return hoverCompletions_1.hover('The View.maxx function is used to determine the maximum value of x for the current graphics mode', 'maxx : int', '(Constant)', [], [], 'Max x size');
                case 'maxy': return hoverCompletions_1.hover('The View.maxy function is used to determine the maximum value of y for the current graphics mode', 'maxy : int', '(Constant)', [], [], 'Max y size');
                case 'maxcolour': return hoverCompletions_1.hover('The View.maxcolour function is used to determine the maximum colour number for the current mode of the screen', 'View.maxcolour : int', '(Constant)', [], [], 'Max colour id');
                case 'Set': return hoverCompletions_1.hover('The View.Set statement is used to change the mode of the screen, as well as the way in which Turing does input and output. The parameter to View.Set is a string, such as "graphics". The string contains one or more options separated by commas, such as "text, noecho". View.Set affects the active window', 'View.Set ( s : string )', '(Procedure)', ['s'], ['Mode to set view to']);
                case 'ClipSet': return hoverCompletions_1.hover('The View.ClipSet procedure sets the clipping region to the rectangle specified by (x1, y1) - (x2, y2). If a clipping region already exist, it is replaced by the specified rectangle', 'View.ClipSet (x1, y1, x2, y2 : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2'], ['Corner 1 X position', 'Corner 1 Y position', 'Corner 2 X position', 'Corner 2 Y position']);
                case 'ClipAdd': return hoverCompletions_1.hover('The View.ClipAdd procedure adds another rectangle specified by (x1, y1) - (x2, y2) to the clipping region. This only works on systems that support complex clipping regions. If no clipping region has been specified, then the rectangle becomes the complete clipping region', 'View.ClipAdd (x1, y1, x2, y2 : int)', '(Procedure)', ['x1', 'y1', 'x2', 'y2'], ['Corner 1 X position', 'Corner 1 Y position', 'Corner 2 X position', 'Corner 2 Y position']);
                case 'ClipAddOval': return hoverCompletions_1.hover('The View.ClipAddOval procedure adds another oval specified by (x, y) and xradius and yradius) to the clipping region. If no clipping region has been specified, then the oval becomes the complete clipping region', ' 	View.ClipAddOval (x, y, xradius, yradius : int)', '(Procedure)', ['x', 'y', 'xradius', 'yradius'], ['Center X position', 'Center Y position', 'Radius along X axis', 'Radius along Y axis']);
                case 'ClipOff': return hoverCompletions_1.hover('The View.ClipOff procedure turns off clipping. This means that any drawing commands can appear on the entire drawing surface (the screen or the window, depending on the system)', 'View.ClipOff', '(Procedure)');
                case 'WhatDotColour': return hoverCompletions_1.hover('The View.WhatDotColour function is used to determine the colour number of the specified pixel', 'View.WhatDotColour ( x, y : int ) : int', '(Function)', ['x', 'y'], ['X position', 'y Position'], 'Output colour id');
                case 'Update': return hoverCompletions_1.hover('The View.Update procedure updates a Run window from an offscreen bitmap. It is used with the command View.Set ("offscreenonly") which prevents the Run window from being updated until the View.Update command is given', 'View.Update', '(Procedure)');
                case 'UpdateArea': return hoverCompletions_1.hover('The View.UpdateArea procedure updates a rectanglular area Run window, specified by (x1, y1) - (x2, y2) from the offscreen bitmap. It is used with the command View.Set ("offscreenonly") which prevents the Run window from being updated until the View.UpdateArea or View.Update command is given', 'View.UpdateArea (x1, y1, x2, y2)', '(Procedure)', ['x1', 'y1', 'x2', 'y2'], ['Corner 1 X position', 'Corner 1 Y position', 'Corner 2 X position', 'Corner 2 Y position']);
            }
        }
        else if (line.search(/(?<=Window.)(Open|Close|GetSelect|Select|SetActive|GetActive|GetPosition|SetPosition|Hide|Show|Set|Update)/) >= 0) {
            switch (sWord) {
                case 'Open': return hoverCompletions_1.hover('The Window.Open function is used to create a window. A window ID is returned if the window is successfully created. If the window is not created then it returns 0. Error.Last and Error.LastMsg can then be used to determine the cause of the failure', 'Window.Open (setUpString : string) : int', '(Function)', ['setUpString'], ['Properties of newly created window'], 'Window id');
                case 'Close': return hoverCompletions_1.hover('The Window.Close procedure closes the window specified by the windowID parameter', 'Window.Close (windowID : int)', '(Procedure)', ['windowID'], ['Window identifier to close']);
                case 'Select': return hoverCompletions_1.hover('The Window.Select selects the window that output is to be sent to', 'Window.Select (windowID : int)', '(Procedure)', ['windowID'], ['Window identifier to select']);
                case 'GetSelect': return hoverCompletions_1.hover('The Window.GetSelect function returns the window ID of the selected window. If the select window is the main (default) run window, then it returns defWinID (which is -1)', 'Window.GetSelect : int', '(Function)', [], [], 'Identifier of currently selected window');
                case 'SetActive': return hoverCompletions_1.hover('The Window.SetActive procedure activates the window specified by the windowID parameter', 'Window.SetActive (windowID : int)', '(Procedure)', ['windowID'], ['Identifier of window to set as active']);
                case 'GetActive': return hoverCompletions_1.hover('The Window.GetActive function returns the window ID of the active window. If the active window is a Turing run window, then Window.GetActive returns defWinID (which is -1) if the window is the default run window, or whatever number was returned from Window.Open for any other run window', 'Window.GetActive : int', '(Function)', [], [], 'Identifier of currently active window');
                case 'GetPosition': return hoverCompletions_1.hover('The Window.GetPosition procedure returns the location of the specified execution window on the screen in the x and y parameters. The x and y parameters specify the lower left corner of the window in screen coordinates. (0, 0) is the lower left corner of the screen', 'Window.GetPosition (windowID : int, var x, y : int)', '(Procedure)', ['windowID', 'x', 'y'], ['Identifier of window', 'Variable set to X position', 'Variable set to Y position']);
                case 'SetPosition': return hoverCompletions_1.hover('The Window.SetPosition procedure moves the location of the specified execution window on the screen. x and y specify the lower left corner of the window in screen coordinates. (0, 0) is the lower left corner of the screen', 'Window.SetPosition (windowID : int, x, y : int)', '(Procedure)', ['windowID', 'x', 'y'], ['Identifier of window to move', 'New X position of window', 'New Y position of window']);
                case 'Hide': return hoverCompletions_1.hover('The Window.Hide procedure hides the specified window. This means it disappears from the user\'s screen. However, it is still possible to select and draw the window while it remains hidden. If the user activates it (using Window.GetActive) it will automatically appear', 'Window.Hide (windowID : int)', '(Procedure)', ['windowID'], ['Identifier of window to hide']);
                case 'Show': return hoverCompletions_1.hover('The Window.Show procedure makes the specified window appear if it was invisible', 'Window.Show (windowID : int)', '(Procedure)', ['windowID'], ['Identifier of window to show']);
                case 'Set': return hoverCompletions_1.hover('The Window.Set procedure sets the configuration of the window specified by the windowID parameter. See View.Set for a complete list of available options. The setUpString parameter can be any combination options, separated by commas. Here is a selection of the available options', 'Window.Set (windowID : int, setUpString : string)', '(Procedure)', ['windowID', 'setUpString'], ['Identifier of window to reconfigure', 'Setup string to reconfigure window']);
                case 'Update': return hoverCompletions_1.hover('The Window.Update procedure updates a specified Run window from an offscreen bitmap. It is used with the command View.Set("offscreenonly") which prevents the Run window from being updated until the Window.Update command is given', 'Window.Update (windowID : int)', '(Procedure)', ['windowID'], ['Identifier of window to update']);
            }
        }
        if (line.search(hoverCompletions_1.moduleRegex) >= 0) {
            switch (word) {
                case 'Config': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with getting configuration information about the machine and environment on which the program is being run', 'Dir', '(Module)');
                case 'Dir': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with directories. You can use these subprograms to list the contents of directories, create directories, change directories and return the current directory', 'Dir', '(Module)');
                case 'Draw': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with drawing pixel graphics to the screen. Most methods require view be set to "graphics"', 'Draw', '(Module)');
                case 'Error': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with errors returned from other predefined subprograms', 'Error', '(Module)');
                case 'File': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with file manipulation on a whole-file basis (as opposed to manipulating the data in the file using open and close, etc.). These routines allow you to rename, copy and delete files, as well as get information about a file and get the free space on disk available for a file', 'File', '(Module)');
                case 'Input': return hoverCompletions_1.hover('This unit contains the predefined procedures that deal with handling input on a character-by-character basis', 'Input', '(Module)');
                case 'Limits': return hoverCompletions_1.hover('This unit contains constants and functions used in determining the mathematical accuracy of the language', 'Limits', '(Module)');
                case 'Math': return hoverCompletions_1.hover('This unit contains all the mathematical routines. There are three routines that are part of the language, but are conceptually part of the Math unit', 'Math', '(Module)');
                case 'Mouse': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with using the mouse in a Turing program', 'Mouse', '(Module)');
                case 'Music': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with sound and music. Some of these routines have not been implemented at the time of the writing of this manual and will be implemented in future releases', 'Music', '(Module)');
                case 'Net': return hoverCompletions_1.hover('The Net module allows TCP/IP equipped machines to communicate. In the current implementation (WinOOT 3.0), this is available only under Win32 (Windows 95, 98, NT and later)', 'Net', '(Module)');
                case 'PC': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with direct access to the hardware under the IBM PC architecture', 'PC', '(Module)');
                case 'RGB': return hoverCompletions_1.hover('This unit contains the predefined constants for the basic colors and the subprograms to change the color palette', 'RGB', '(Module)');
                case 'Stream': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with I/O streams. The basic I/O in Turing is done with I/O statements. However, extra functions are all part of the Stream unit', 'Stream', '(Module)');
                case 'Str': return hoverCompletions_1.hover('This unit contains the predefined constants for manipulating strings', 'Str', '(Module)');
                case 'Sys': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with the operating system directly (getting the process id, getting run time arguments and executing commands in the operating system, etc.)', 'Sys', '(Module)');
                case 'Text': return hoverCompletions_1.hover('This unit contains the predefined subprograms that handle character (text) output on the screen (i.e. output using put)', 'Text', '(Module)');
                case 'Time': return hoverCompletions_1.hover('This unit contains the predefined subprograms that handle anything to do with time, either as a date or as a timer', 'Time', '(Module)');
                case 'View': return hoverCompletions_1.hover('This unit contains the predefined subprograms that deal with the current output surface, which is a window', 'View', '(Module)');
                case 'Window': return hoverCompletions_1.hover('This unit contains the predefined subprograms that handle windows. There are routines to open, close, hide, show and select windows', 'Window', '(Module)');
            }
        }
    }
});
exports.operatorHoverProvider = vscode.languages.registerHoverProvider('t', {
    provideHover(doc, pos) {
        const range = doc.getWordRangeAtPosition(pos, hoverCompletions_1.operatorRegex);
        const word = doc.getText(range);
        switch (word) {
            case '+': return hoverCompletions_1.hover('Addition/concatenation operator');
            case '-': return hoverCompletions_1.hover('Subtraction operator');
            case '*': return hoverCompletions_1.hover('Multiplication operator');
            case '/': return hoverCompletions_1.hover('Decimal division operator');
            case '**': return hoverCompletions_1.hover('Exponent operator');
            case '<': return hoverCompletions_1.hover('Less than operator');
            case '>': return hoverCompletions_1.hover('Greater than operator');
            case '=': return hoverCompletions_1.hover('Is equal operator');
            case '<=': return hoverCompletions_1.hover('Less or equal to operator');
            case '>=': return hoverCompletions_1.hover('Greater or equal to operator');
            case 'not': return hoverCompletions_1.hover('Bool not operator');
            case 'and': return hoverCompletions_1.hover('Bool and operator');
            case 'or': return hoverCompletions_1.hover('Bool or operator');
            case 'xor': return hoverCompletions_1.hover('Bool xor operator');
            case 'div': return hoverCompletions_1.hover('Floor division operator');
            case 'mod': return hoverCompletions_1.hover('Modulo operator');
            case 'shr': return hoverCompletions_1.hover('Shift right operator');
            case 'shl': return hoverCompletions_1.hover('Shift left operator');
            case 'in': return hoverCompletions_1.hover('In operator');
            case '^': return hoverCompletions_1.hover('Pointer operator');
            case ':': return hoverCompletions_1.hover('Datatype operator');
            case '->': return hoverCompletions_1.hover('Access property operator');
            case ':=': return hoverCompletions_1.hover('Set operator');
        }
    }
});
//# sourceMappingURL=hoverProvider.js.map